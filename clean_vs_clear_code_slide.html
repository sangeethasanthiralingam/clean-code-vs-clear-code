<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Clean Code vs. Clear Code - Technical Deep Dive</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- Projector Presentation Wrapper -->
  <div class="presentation-container">
    <!-- Slides START -->
    <!-- Slide 1: Hook Slide (NEW) -->
    <div class="slide active hook-slide">
      <div class="hook-question">
        How many of you have opened a file, looked at the code, and immediately wanted to rewrite it?
      </div>
      <div class="hook-subtitle">
        That feeling is exactly why we're here today
      </div>
      <div class="hook-stats">
        <div class="stat-card">
          <div class="stat-number">80%</div>
          <div class="stat-label">of code time is spent reading, not writing</div>
        </div>
        <div class="stat-card">
          <div class="stat-number">60%</div>
          <div class="stat-label">of bugs come from unclear requirements</div>
        </div>
        <div class="stat-card">
          <div class="stat-number">90%</div>
          <div class="stat-label">of developer frustration comes from bad code</div>
        </div>
      </div>
    </div>

    <!-- Slide 2: Title -->
    <div class="slide title-slide">
      <h1 class="slide-title">Clean Code vs. Clear Code: Finding the Right Balance</h1>
      <div class="author-info">
        <p>
          Sangeetha Santhiralingam<br>
          Software Engineer<br>
          HNDIT | Reading BSc (Hons) in Software Engineering<br>
          Presenting on: <!-- You can update the date below as needed -->
          2025-06-28
        </p>
      </div>
    </div>

    <!-- Slide 3: Martin's Quote -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">The Foundation</h1>
        <p class="slide-subtitle">What drives good code practices</p>
      </div>
      <!-- <div style="margin-bottom: 30px; text-align: center; font-size: 1.1rem; color: #764ba2;">
        <strong>Opening Hook:</strong> How many of you have opened a file, looked at the code, and immediately wanted to
        rewrite it? That feeling is exactly why we're here today.
      </div> -->
      <div class="quote">
        "Any fool can write code that a computer can understand. Good
        programmers write code that humans can understand."
        <div class="quote-author">- Robert C. Martin (Uncle Bob)</div>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßπ Clean Code Philosophy</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Code should be elegant and efficient</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Bad code tempts the mess to grow</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Clean code can be read like well-written prose</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Each function, class, and module should have a single
                responsibility</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üîç Clear Code Philosophy</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">The name should reduce any confusion about what a software
                entity does</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Immediate comprehension over architectural elegance</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Explicit over implicit behavior</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Minimize cognitive load for the reader</span>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Slide 4: Martin's Clean Code Rules -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Uncle Bob's Clean Code Rules</h1>
        <p class="slide-subtitle">Core principles from "Clean Code"</p>
      </div>
      <div style="margin-bottom: 20px; text-align: center; color: #667eea; font-size: 1.1rem;">
        <strong>Quick Poll:</strong> How many of you follow Clean Code principles strictly? (Show of hands)
      </div>
      <div class="rules-grid">
        <div class="rule-card">
          <div class="rule-number">1</div>
          <div class="rule-title">Meaningful names</div>
          <div class="rule-text">
            Use intention-revealing names. Avoid disinformation. Make
            meaningful distinctions.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">2</div>
          <div class="rule-title">Functions Should Be Small</div>
          <div class="rule-text">
            Functions should be 20 lines or fewer. Do one thing. Have no side
            effects.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">3</div>
          <div class="rule-title">Comments</div>
          <div class="rule-text">
            Don't comment bad code‚Äîrewrite it. Good code mostly documents
            itself.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">4</div>
          <div class="rule-title">Error Handling</div>
          <div class="rule-text">
            Use exceptions rather than return codes. Don't return null.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">5</div>
          <div class="rule-title">Classes</div>
          <div class="rule-text">
            Classes should be small. Single Responsibility Principle. High
            cohesion.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">6</div>
          <div class="rule-title">Systems</div>
          <div class="rule-text">
            Separate constructing a system from using it. Use dependency
            injection.
          </div>
        </div>
      </div>
    </div>

    <!-- Slide 5: Clear Code Technical Principles -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Clear Code Technical Principles</h1>
        <p class="slide-subtitle">Readability-first programming practices</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">1. Naming for Humans</h3>
          <p class="principle-description">
            Names should immediately communicate purpose without requiring
            context. Prefer `getUserAccountBalance()` over `getUAB()` or
            `calculate()`.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">2. Linear Code Flow</h3>
          <p class="principle-description">
            Code should read top-to-bottom like a newspaper. Avoid deeply
            nested conditions and callbacks that break linear comprehension.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">3. Explicit Over Clever</h3>
          <p class="principle-description">
            Prefer explicit, verbose solutions over clever one-liners. Code is
            read far more often than it's written.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">4. Consistent Formatting</h3>
          <p class="principle-description">
            Consistency in formatting improves readability. Establish a
            pattern for how you write your code, such as indentation and
            spacing.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">5. Single Level of Abstraction</h3>
          <p class="principle-description">
            Each function should operate at one level of abstraction. Don't
            mix high-level business logic with low-level implementation
            details.
          </p>
        </div>
      </div>
    </div>

    <!-- Slide 6: Naming Conventions - Technical Comparison -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Naming Conventions: Technical Examples</h1>
        <p class="slide-subtitle">Clean Code vs. Clear Code approaches</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #764ba2; font-size: 1.05rem;">
        <strong>Engagement:</strong> Before we look at the examples, who can guess which approach would prefer longer,
        more descriptive variable names?
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">
            ‚ùå Poor Naming (Both Approaches Reject)
          </div>
          <pre>
function calc(u, t) {
  return u * t * 0.1;
}

let d = new Date();
let usr = getUsr();
let flag = false;</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Clean Code Approach</div>
          <pre>
class TaxCalculator {
  calculateTax(amount: Money, rate: TaxRate): Money {
    return amount.multiply(rate.getValue());
  }
}

const taxCalculator = new TaxCalculator();
const currentDate = DateTimeProvider.now();</pre>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Clear Code Approach</div>
          <pre>
function calculateTaxAmount(orderAmount, taxRate) {
  return orderAmount * taxRate;
}

function isUserAccountActive(user) {
  return user.status === 'active' && 
         user.subscriptionEndDate > new Date();
}</pre>
        </div>
        <div class="code-example">
          <div class="code-title">Key Differences</div>
          <pre>
Clean Code:
‚Ä¢ Strong typing
‚Ä¢ Domain objects
‚Ä¢ Design patterns
‚Ä¢ Abstraction layers

Clear Code:
‚Ä¢ Descriptive names
‚Ä¢ Simple functions
‚Ä¢ Direct logic
‚Ä¢ Minimal abstraction</pre>
        </div>
      </div>
    </div>

    <!-- Slide 7: Functions - Technical Deep Dive -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Function Design: Technical Comparison</h1>
        <p class="slide-subtitle">Martin's rules vs. Clarity principles</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #764ba2; font-size: 1.05rem;">
        <strong>Exercise:</strong> Spot the difference! What stands out to you between these two code examples?
      </div>
      <div class="example-section">
        <div class="example-title">User Validation Example</div>
        <div class="code-container">
          <div class="code-example">
            <div class="code-title">
              Clean Code: Single Responsibility + Abstraction
            </div>
            <pre>
class UserValidator {
  private emailValidator: EmailValidator;
  private ageValidator: AgeValidator;
  
  validate(user: User): ValidationResult {
    const emailResult = this.emailValidator.validate(user.email);
    const ageResult = this.ageValidator.validate(user.age);
    
    return ValidationResult.combine(emailResult, ageResult);
  }
}

class EmailValidator {
  validate(email: Email): ValidationResult {
    return email.isValid() 
      ? ValidationResult.success()
      : ValidationResult.failure("Invalid email format");
  }
}</pre>
          </div>
          <div class="code-example">
            <div class="code-title">Clear Code: Direct and Explicit</div>
            <pre>
function validateUser(user) {
  const errors = [];
  
  // Check email format
  if (!user.email || !user.email.includes('@')) {
    errors.push('Email must contain @ symbol');
  }
  
  // Check age requirement
  if (!user.age || user.age < 18) {
    errors.push('User must be 18 or older');
  }
  
  // Check required fields
  if (!user.name || user.name.trim().length < 2) {
    errors.push('Name must be at least 2 characters');
  }
  
  return {
    isValid: errors.length === 0,
    errors: errors
  };
}</pre>
          </div>
        </div>
      </div>
    </div>

    <!-- Slide 8: Error Handling Patterns -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Error Handling: Technical Approaches</h1>
        <p class="slide-subtitle">Exceptions vs. explicit error handling</p>
      </div>
      <div class="code-container">
        <div class="code-example">
          <div class="code-title">Clean Code: Exception-Based</div>
          <pre>
class UserService {
  async createUser(userData: UserData): Promise&lt;User&gt; {
    try {
      const validatedData = this.validator.validate(userData);
      const user = await this.repository.save(validatedData);
      await this.emailService.sendWelcomeEmail(user);
      return user;
    } catch (ValidationError error) {
      throw new UserCreationError('Validation failed', error);
    } catch (DatabaseError error) {
      throw new UserCreationError('Database operation failed', error);
    }
  }
}</pre>
        </div>
        <div class="code-example">
          <div class="code-title">Clear Code: Explicit Return Values</div>
          <pre>
async function createUser(userData) {
  // Validate input
  const validationResult = validateUserData(userData);
  if (!validationResult.success) {
    return {
      success: false,
      error: 'Validation failed: ' + validationResult.message,
      user: null
    };
  }
  
  // Save to database
  const saveResult = await saveUserToDatabase(userData);
  if (!saveResult.success) {
    return {
      success: false,
      error: 'Failed to save user: ' + saveResult.error,
      user: null
    };
  }
  
  // Send welcome email (optional, don't fail if this fails)
  const emailResult = await sendWelcomeEmail(saveResult.user);
  if (!emailResult.success) {
    console.warn('Welcome email failed:', emailResult.error);
  }
  
  return {
    success: true,
    error: null,
    user: saveResult.user
  };
}</pre>
        </div>
      </div>
    </div>

    <!-- Slide 9: Anti-patterns and Solutions -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Common Anti-patterns</h1>
        <p class="slide-subtitle">What both approaches avoid</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #e53e3e; font-size: 1.05rem;">
        <strong>Engagement:</strong> Look at these anti-patterns - raise your hand if you've seen this in production
        code!
      </div>
      <div class="antipattern-grid">
        <div class="antipattern-card">
          <div class="antipattern-title">‚ùå God Functions</div>
          <p>
            Functions that do everything. Both approaches advocate for
            smaller, focused functions, but for different reasons.
          </p>
        </div>
        <div class="pattern-card">
          <div class="pattern-title">‚úÖ Focused Functions</div>
          <p>
            Clean Code: Single Responsibility Principle<br />Clear Code: Easy
            to understand and test
          </p>
        </div>
        <div class="antipattern-card">
          <div class="antipattern-title">‚ùå Cryptic Abbreviations</div>
          <p>
            Variables like `usr`, `calc`, `proc`. Both demand meaningful
            names, though implementation differs.
          </p>
        </div>
        <div class="pattern-card">
          <div class="pattern-title">‚úÖ Descriptive Names</div>
          <p>
            Clean Code: Domain-driven naming<br />Clear Code: Human-readable
            descriptions
          </p>
        </div>
        <div class="antipattern-card">
          <div class="antipattern-title">‚ùå Deep Nesting</div>
          <p>
            Multiple levels of if/else and loops that hurt readability and
            maintainability.
          </p>
        </div>
        <div class="pattern-card">
          <div class="pattern-title">‚úÖ Early Returns</div>
          <p>
            Guard clauses and early exits to reduce cognitive load and improve
            flow.
          </p>
        </div>
      </div>

      <!-- Code Examples Section -->
      <div style="margin-top: 30px;">
        <!-- God Functions Example -->
        <div class="example-section">
          <div class="example-title">üí• 1Ô∏è‚É£ God Functions</div>
          <div class="code-container">
            <div class="code-example code-bad">
              <div class="code-title">‚ùå Bad: God Function</div>
              <pre>
def processOrder(order):
    # validate
    if not order.items:
        print("No items")
        return
    # calculate total
    total = 0
    for item in order.items:
        total += item.price * item.quantity
    # apply discount
    if order.coupon:
        total *= 0.9
    # update inventory
    for item in order.items:
        item.stock -= item.quantity
    # send email
    print(f"Order processed. Total: ${total}")</pre>
            </div>
            <div class="code-example code-good">
              <div class="code-title">‚úÖ Good: Focused Functions</div>
              <pre>
def validateOrder(order):
    if not order.items:
        raise ValueError("No items in order")

def calculateTotal(order):
    total = sum(item.price * item.quantity for item in order.items)
    if order.coupon:
        total *= 0.9
    return total

def updateInventory(order):
    for item in order.items:
        item.stock -= item.quantity

def processOrder(order):
    validateOrder(order)
    total = calculateTotal(order)
    updateInventory(order)
    print(f"Order processed. Total: ${total}")</pre>
            </div>
          </div>
        </div>

        <!-- Cryptic Abbreviations Example -->
        <div class="example-section">
          <div class="example-title">üí• 2Ô∏è‚É£ Cryptic Abbreviations</div>
          <div class="code-container">
            <div class="code-example code-bad">
              <div class="code-title">‚ùå Bad</div>
              <pre>
def calc(p, q):
    return p * q * 0.95</pre>
            </div>
            <div class="code-example code-good">
              <div class="code-title">‚úÖ Good</div>
              <pre>
def calculateDiscountedPrice(price, quantity):
    return price * quantity * 0.95</pre>
            </div>
          </div>
        </div>

        <!-- Deep Nesting Example -->
        <div class="example-section">
          <div class="example-title">üí• 3Ô∏è‚É£ Deep Nesting</div>
          <div class="code-container">
            <div class="code-example code-bad">
              <div class="code-title">‚ùå Bad</div>
              <pre>
def processUser(user):
    if user.isActive:
        if user.hasProfile:
            if user.profile.isComplete:
                print("User is valid")</pre>
            </div>
            <div class="code-example code-good">
              <div class="code-title">‚úÖ Good (Early Returns)</div>
              <pre>
def processUser(user):
    if not user.isActive:
        return
    if not user.hasProfile:
        return
    if not user.profile.isComplete:
        return
    print("User is valid")</pre>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Slide 10: SOLID Principles Deep Dive -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">SOLID Principles in Practice</h1>
        <p class="slide-subtitle">Clean Code's architectural foundation</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">S - Single Responsibility Principle</h3>
          <p class="principle-description">
            A class should have only one reason to change. Each class should
            have only one job or responsibility.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">O - Open/Closed Principle</h3>
          <p class="principle-description">
            Software entities should be open for extension but closed for
            modification. Add new functionality without changing existing
            code.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">L - Liskov Substitution Principle</h3>
          <p class="principle-description">
            Objects of a superclass should be replaceable with objects of a
            subclass without breaking the application.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">I - Interface Segregation Principle</h3>
          <p class="principle-description">
            Clients should not be forced to depend on interfaces they don't
            use. Create specific, focused interfaces.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">D - Dependency Inversion Principle</h3>
          <p class="principle-description">
            Classes should depend upon interfaces or abstract classes instead
            of concrete classes.
          </p>
        </div>
      </div>
    </div>

    <!-- Slide 11: When to Choose Which Approach -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Decision Matrix: When to Choose Which</h1>
        <p class="slide-subtitle">Technical factors for approach selection</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #667eea; font-size: 1.05rem;">
        <strong>Reflection:</strong> Think about your current project‚Äîwhere does it fit in this matrix? What trade-offs are you currently making between readability and maintainability? (Share with your neighbor)
      </div>
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Factor</th>
            <th>Choose Clean Code When...</th>
            <th>Choose Clear Code When...</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Project Lifespan</strong></td>
            <td>Long-term (2+ years), multiple iterations</td>
            <td>Short-term scripts, prototypes, one-offs</td>
          </tr>
          <tr>
            <td><strong>Team Size</strong></td>
            <td>Large teams (5+ developers)</td>
            <td>Small teams (1-3 developers)</td>
          </tr>
          <tr>
            <td><strong>Code Complexity</strong></td>
            <td>Complex business logic, multiple domains</td>
            <td>Straightforward CRUD, minimal domain logic or business rules</td>
          </tr>
          <tr>
            <td><strong>Performance Requirements</strong></td>
            <td>Can afford abstraction overhead</td>
            <td>Need maximum performance, minimal abstraction layers and runtime overhead</td>
          </tr>
          <tr>
            <td><strong>Readability vs. Maintainability</strong></td>
            <td>Maintainability is critical</td>
            <td>Immediate understanding for current reader is paramount, even at cost of future flexibility</td>
          </tr>
          <tr>
            <td><strong>Codebase Age</strong></td>
            <td>Legacy code that needs refactoring</td>
            <td>New code that needs to be immediately understandable</td>
          </tr>
          <tr>
            <td><strong>Future Extension</strong></td>
            <td>Expect frequent feature additions or evolving requirements</td>
            <td>No significant future changes expected</td>
          </tr>
          <tr>
            <td><strong>Onboarding New Devs</strong></td>
            <td>Important to make architecture easy for new team members to understand over time</td>
            <td>Code will be used by known, small set of people who can quickly understand simpler approaches</td>
          </tr>
          <tr>
            <td><strong>Testing & Coverage</strong></td>
            <td>High automated test coverage required, needs solid structure to support testing</td>
            <td>Manual testing or throwaway code with minimal test requirements</td>
          </tr>
          <tr>
            <td><strong>Documentation Need</strong></td>
            <td>Expect thorough documentation to support longevity and handoff</td>
            <td>Documentation can be light because code is self-explanatory and short-lived</td>
          </tr>
          <tr>
            <td><strong>Regulatory/Compliance</strong></td>
            <td>Must meet compliance standards (e.g., medical, finance)</td>
            <td>No compliance or audit constraints</td>
          </tr>
        </tbody>
      </table>
    </div>
    <!-- Slide 12: Advanced Naming Techniques -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Advanced Naming Techniques</h1>
        <p class="slide-subtitle">Naming strategies from Clean Code and Clear Code</p>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code Approach</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Domain-driven names:</strong> Use business terms consistently across the whole system (e.g., `Invoice`, `calculateTaxAmount`).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Avoid abbreviations:</strong> Use full words (`customerAddress`) instead of shortcuts (`custAddr`).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Positive boolean names:</strong> Prefer affirmations like `isEligibleForDiscount()` over confusing negations.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Action verbs for functions:</strong> Start names with verbs (`get`, `set`, `find`, `validate`, `update`, `send`).</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code Approach</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Human-first names:</strong> Prioritize immediate comprehension over strict domain correctness (e.g., `getCustomerBalance()` vs. `calcCustBal()`).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Contextual clarity:</strong> Names should make sense in isolation, without needing to cross-reference other code.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Function length vs. name detail:</strong> Longer functions require more descriptive names; very short functions can be simpler.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Avoid redundant context:</strong> Don't repeat unnecessary parts (e.g., `user.getUser()` ‚Üí `user.get()`).</span>
            </li>
          </ul>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">‚ùå Poor Naming</div>
          <pre>function calc(u, t) {
  return u * t * 0.1; // What is calc? What are u and t?
}
let d = new Date();    // What does d represent?
let flag = false;      // Flag for what?</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Good Naming</div>
          <pre>function calculateTaxAmount(orderAmount, taxRate) {
  return orderAmount * taxRate;
}
const currentDate = DateTimeProvider.now();

// Clear, specific, self-explanatory</pre>
        </div>
      </div>
    </div>
    <!-- Slide 13: Functions with Fewer Side Effects -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Functions with Fewer Side Effects</h1>
        <p class="slide-subtitle">How Clean Code and Clear Code reduce unintended behavior</p>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code Perspective</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Pure functions:</strong> Always produce the same output for the same input and do not modify external state or rely on hidden inputs.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Command-Query Separation:</strong> A function should either return data OR change state‚Äînever both.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Avoid global variables:</strong> Prevent unpredictable dependencies and bugs by avoiding global or static state.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Testable design:</strong> Pure, side-effect-free functions are easier to test and reason about.</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code Perspective</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Explicit behavior:</strong> Use clear names to signal side effects (e.g., `saveUser()` clearly implies a write action).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Minimize mutation:</strong> Return new objects instead of changing arguments directly whenever possible.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Read-only functions:</strong> Prefer functions that only read and return data; they are safer and easier to understand.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Single action per function:</strong> Split functions with multiple side effects into smaller, more focused ones.</span>
            </li>
          </ul>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">‚ùå Bad Example</div>
          <pre>function updateCart(cart, item) {
  cart.items.push(item);
  cart.total += item.price;
}

// ‚ö†Ô∏è Directly mutates cart, making state management 
// and debugging harder.</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Good Example</div>
          <pre>function addItemToCart(cart, item) {
  const newItems = [...cart.items, item];
  const newTotal = cart.total + item.price;
  return { ...cart, items: newItems, total: newTotal };
}

// ‚úÖ Creates and returns a new cart object without 
// mutating the original; easier to test and predict.</pre>
        </div>
      </div>
    </div>
    <!-- Slide: Hybrid Approach -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Hybrid Approach: Best of Both Worlds</h1>
        <p class="slide-subtitle">When to combine Clean Code and Clear Code</p>
      </div>
      
      <!-- Why Use Hybrid Section -->
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">‚úÖ Why use a hybrid?</h3>
          <ul style="list-style-type: disc; padding-left: 20px; color: #555; margin-top: 10px;">
            <li><strong>Real-world constraints:</strong> You often need maintainability (Clean Code) and immediate readability (Clear Code), especially on fast-moving projects.</li>
            <li><strong>Team diversity:</strong> Some teammates prefer structured abstractions, while others need quick, direct understanding.</li>
            <li><strong>Balanced performance and design:</strong> You can keep critical paths direct and clear while maintaining an overall clean, testable architecture.</li>
          </ul>
        </div>
      </div>

      <!-- Practical Example Section -->
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">üí° Practical Example</h3>
          <pre style="background:#2d3748;color:#e2e8f0;padding:15px;border-radius:8px;font-size:0.95rem;overflow-x:auto;"><code>class UserService {
  // Clean Code: Strong typing and single responsibility
  async createUserAccount(userData: CreateUserRequest): Promise&lt;{ success: boolean; user?: User; errors?: string[] }&gt; {
    // Clear Code: Explicit step-by-step logic

    // Step 1: Validate
    const validationErrors = this.validateUserData(userData);
    if (validationErrors.length > 0) {
      return { success: false, errors: validationErrors };
    }

    // Step 2: Save to database
    const newUser = await this.saveUserToDatabase(userData);

    // Step 3: Send welcome email
    await this.sendWelcomeEmail(newUser);

    // Step 4: Return success
    return { success: true, user: newUser };
  }

  private validateUserData(userData: CreateUserRequest): string[] {
    const errors: string[] = [];
    if (!userData.email.includes('@')) {
      errors.push('Invalid email format.');
    }
    if (userData.password.length < 8) {
      errors.push('Password must be at least 8 characters.');
    }
    return errors;
  }

  private async saveUserToDatabase(userData: CreateUserRequest): Promise&lt;User&gt; {
    // Imagine ORM or repository logic here
    return db.user.create(userData);
  }

  private async sendWelcomeEmail(user: User): Promise&lt;void&gt; {
    // Email service logic here
    await emailService.send({
      to: user.email,
      subject: 'Welcome!',
      body: 'Thank you for joining us.',
    });
  }
}</code></pre>
        </div>
      </div>

      <!-- Why This is Hybrid Section -->
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code Elements</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Strong typing:</strong> `CreateUserRequest`, `User` types</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Small, single-purpose methods:</strong> `validateUserData`, `saveUserToDatabase`, `sendWelcomeEmail`</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Separation of concerns:</strong> Each method has one clear responsibility</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Testable design:</strong> Private methods can be easily unit tested</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code Elements</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Straightforward, linear flow:</strong> Easy to read without jumping around</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Explicit, descriptive names:</strong> Clearly show each step</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Immediate error handling:</strong> Validation logic up front</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Step-by-step comments:</strong> Guide the reader through the process</span>
            </li>
          </ul>
        </div>
      </div>

      <!-- Practical Takeaway Section -->
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">üí¨ Practical Takeaway</h3>
          <div style="background: #f7fafc; border-left: 4px solid #667eea; padding: 15px; margin-top: 10px; border-radius: 0 8px 8px 0;">
            <p style="margin: 0; font-style: italic; color: #4a5568;">
              Combine <strong>clean architectural structure</strong> (abstractions, testability) with <strong>clear, easy-to-follow local logic</strong> (linear steps, explicit conditions) to make your code robust <em>and</em> approachable.
            </p>
          </div>
        </div>
      </div>
    </div>
    <!-- Slide: FAQ & Migration Strategies -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">FAQ & Migration Strategies</h1>
        <p class="slide-subtitle">Addressing common concerns and transitions when balancing Clean and Clear Code</p>
      </div>
      
      <!-- FAQ Section -->
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">‚ùì Q: What if my team strongly prefers one style?</h3>
          <p class="principle-description">
            <strong>‚úÖ A:</strong><br>
            ‚Ä¢ Align on shared guidelines early (e.g., in your engineering handbook or contribution guide).<br>
            ‚Ä¢ Allow flexibility depending on context (e.g., tight deadline prototypes vs. core domain modules).<br>
            ‚Ä¢ Document style decisions clearly in code comments or design docs, so future contributors understand <em>why</em> you chose a particular style.
          </p>
        </div>
        
        <div class="principle-card">
          <h3 class="principle-title">‚ùì Q: How do we migrate legacy code to a cleaner or clearer style?</h3>
          <p class="principle-description">
            <strong>‚úÖ A:</strong><br>
            ‚Ä¢ <strong>Refactor incrementally</strong>, not all at once (big rewrites are risky and costly).<br>
            ‚Ä¢ Prioritize high-churn or business-critical areas (where changes happen most and bugs are costly).<br>
            ‚Ä¢ Write or improve tests first to protect behavior before refactoring.<br>
            ‚Ä¢ Use feature flags or gradual rollouts to manage risk if the changes are large.<br>
            ‚Ä¢ Adopt a "boy scout rule": Leave code cleaner than you found it whenever you touch it.
          </p>
        </div>
        
        <div class="principle-card">
          <h3 class="principle-title">‚ùì Q: Will introducing Clean Code slow us down?</h3>
          <p class="principle-description">
            <strong>‚úÖ A:</strong><br>
            ‚Ä¢ There can be an upfront learning and design cost, but it reduces long-term maintenance pain.<br>
            ‚Ä¢ For one-off scripts or temporary experiments, it's fine to lean more on Clear Code and speed.<br>
            ‚Ä¢ Balance rigor with delivery needs ‚Äî optimize for long-term value when code will live for years.
          </p>
        </div>
        
        <div class="principle-card">
          <h3 class="principle-title">‚ùì Q: Can we mix Clean and Clear Code within the same project?</h3>
          <p class="principle-description">
            <strong>‚úÖ A:</strong><br>
            ‚Ä¢ Absolutely ‚Äî this is the hybrid approach.<br>
            ‚Ä¢ Use Clean Code for core architecture, shared utilities, and domain-heavy logic.<br>
            ‚Ä¢ Use Clear Code for small helpers, glue code, or fast paths that need to be immediately understood.<br>
            ‚Ä¢ The key: be intentional and consistent in <em>where</em> you use each style.
          </p>
        </div>
      </div>

      <!-- Migration Tips Section -->
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">üõ†Ô∏è Migration Tips</h3>
          <ul style="list-style-type: disc; padding-left: 20px; color: #555; margin-top: 10px;">
            <li>Start by <strong>introducing clear naming and function extraction</strong> ‚Äî these are low-risk, high-impact.</li>
            <li>Encourage code reviews to reinforce shared style gradually.</li>
            <li>Monitor code health metrics (e.g., code churn, bug rates) to measure improvements over time.</li>
          </ul>
        </div>
      </div>

      <!-- Final Note Section -->
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">‚úÖ Final Note</h3>
          <div style="background: #f7fafc; border-left: 4px solid #667eea; padding: 15px; margin-top: 10px; border-radius: 0 8px 8px 0;">
            <p style="margin: 0; font-style: italic; color: #4a5568;">
              "Consistency is more important than perfection. A pragmatic, gradual approach keeps your codebase healthy without slowing your team down."
            </p>
          </div>
        </div>
      </div>
    </div>
    <!-- Slide: Tooling & IDE Support -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Tooling & IDE Support</h1>
        <p class="slide-subtitle">How tools help enforce Clean and Clear Code principles</p>
      </div>
      
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code Tools</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">
                <strong>Linters</strong><br>
                <em>Examples:</em> ESLint (JavaScript/TypeScript), Pylint (Python), TSLint (TypeScript legacy)<br>
                ‚Üí Enforce consistent code style, catch anti-patterns, and enforce architectural rules.
              </span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">
                <strong>Static analysis</strong><br>
                <em>Examples:</em> SonarQube, CodeClimate, DeepSource<br>
                ‚Üí Identify code smells, technical debt, complex dependencies, and security issues early.
              </span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">
                <strong>Refactoring tools</strong><br>
                <em>Examples:</em> IDE built-ins (VSCode, IntelliJ), Resharper (.NET), Rider, PyCharm<br>
                ‚Üí Make safe structural changes (rename, extract, move, etc.) to support maintainability without manual errors.
              </span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code Tools</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">
                <strong>Auto-formatters</strong><br>
                <em>Examples:</em> Prettier (JavaScript/TypeScript), Black (Python), gofmt (Go)<br>
                ‚Üí Ensure uniform, instantly readable formatting automatically ‚Äî reduces friction in code reviews.
              </span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">
                <strong>Naming suggestions and completions</strong><br>
                <em>Examples:</em> IntelliSense (VSCode, Visual Studio), Copilot (GitHub), TabNine<br>
                ‚Üí Encourage more descriptive, human-friendly names while writing code in real time.
              </span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">
                <strong>Readability & clarity plugins</strong><br>
                <em>Examples:</em> Code Spell Checker (VSCode), Highlight Matching Tag (VSCode), Bracket Pair Colorizer<br>
                ‚Üí Improve quick comprehension, especially for large files or nested structures.
              </span>
            </li>
          </ul>
        </div>
      </div>

      <!-- Key Takeaway Section -->
      <div class="single-column" style="margin-top: 30px;">
        <div class="principle-card">
          <h3 class="principle-title">üí° Key Takeaway</h3>
          <div style="background: #f7fafc; border-left: 4px solid #667eea; padding: 15px; margin-top: 10px; border-radius: 0 8px 8px 0;">
            <p style="margin: 0; font-style: italic; color: #4a5568;">
              Tools <strong>amplify team discipline</strong> ‚Äî they can't replace thoughtful design, but they make it easier to stay consistent and catch issues early.
            </p>
          </div>
        </div>
      </div>

  
    </div>
    <!-- Slide: Industry Examples -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Industry Examples: Clean vs. Clear Code</h1>
        <p class="slide-subtitle">How major companies balance these approaches</p>
      </div>
      
      <!-- Company Comparison Table -->
      <div class="single-column" style="margin-bottom: 30px;">
        <table class="comparison-table" style="font-size: 0.9rem;">
          <thead>
            <tr>
              <th style="width: 15%;">Company / Context</th>
              <th style="width: 25%;">Clean Code Focus</th>
              <th style="width: 25%;">Clear Code Focus</th>
              <th style="width: 35%;">Why?</th>
            </tr>
          </thead>
          <tbody>
            <tr style="background-color: #f0f8f0;">
              <td><strong>üü¢ Google</strong></td>
              <td>
                ‚úÖ Strict style guides<br>
                ‚úÖ Heavy code reviews<br>
                ‚úÖ SOLID & architectural rigor
              </td>
              <td>‚ö™ Less emphasis on minimalism in local logic</td>
              <td>Global scale and long-term maintainability</td>
            </tr>
            <tr style="background-color: #f0f0f8;">
              <td><strong>üîµ Microsoft</strong></td>
              <td>
                ‚úÖ Maintainability<br>
                ‚úÖ Legacy support<br>
                ‚úÖ Extensive testing & strong abstractions
              </td>
              <td>‚ö™ Some products (e.g., experiments) move faster</td>
              <td>Large, mature products require stability</td>
            </tr>
            <tr style="background-color: #f8f0f8;">
              <td><strong>üü£ Airbnb</strong></td>
              <td>
                ‚úÖ Typed, reusable components<br>
                ‚úÖ Strong design patterns in React/TS
              </td>
              <td>‚ö™ Rapid feature dev sometimes favors local clarity</td>
              <td>Balances product speed and engineering scale</td>
            </tr>
            <tr style="background-color: #fff8f0;">
              <td><strong>üü† Startups</strong></td>
              <td>‚ö™ Light abstractions</td>
              <td>
                ‚úÖ Fast prototyping<br>
                ‚úÖ Simple structures
              </td>
              <td>Need speed and quick iteration</td>
            </tr>
            <tr style="background-color: #fffff0;">
              <td><strong>üü° Open source</strong></td>
              <td>‚ö™ Some shared core infra modules are clean-coded</td>
              <td>
                ‚úÖ Prioritize broad readability<br>
                ‚úÖ Explicit flow
              </td>
              <td>New contributors need to understand code quickly</td>
            </tr>
            <tr style="background-color: #f8f0f0;">
              <td><strong>üü§ Figma, Notion</strong></td>
              <td>‚ö™ Core infra uses clean patterns internally</td>
              <td>
                ‚úÖ App layers emphasize clear, direct logic
              </td>
              <td>Collaboration-friendly and fast UI iteration</td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Hybrid Example Section -->
      <div class="single-column" style="margin-bottom: 30px;">
        <div class="principle-card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
          <h3 class="principle-title" style="color: white;">üí° Hybrid Example: Facebook / Meta</h3>
          <div style="display: flex; gap: 20px; margin-top: 15px;">
            <div style="flex: 1; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
              <h4 style="color: white; margin-top: 0;">üßº Core Frameworks & Shared Infra</h4>
              <p style="color: white; margin: 0;">Clean Code approach with rigid patterns and strong typing for long-term stability</p>
            </div>
            <div style="flex: 1; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
              <h4 style="color: white; margin-top: 0;">üëÅÔ∏è Product Surfaces & A/B Tests</h4>
              <p style="color: white; margin: 0;">Clear Code approach for quick changes and explicit behavior in fast-moving features</p>
            </div>
          </div>
          <p style="color: white; margin-top: 15px; font-style: italic;">
            <strong>Why?</strong> Enables both fast experiments and long-term code health
          </p>
        </div>
      </div>

      <!-- Key Takeaway Section -->
      <div class="single-column">
        <div class="principle-card" style="background: #f7fafc; border-left: 4px solid #667eea;">
          <h3 class="principle-title">‚úÖ Key Takeaway</h3>
          <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <p style="margin: 0; font-size: 1.1rem; line-height: 1.6; color: #2d3748;">
              <strong>"Use Clean Code for stability and shared foundations.<br>
              Use Clear Code for fast-moving, user-facing, or experimental parts.<br>
              Mix them intentionally ‚Äî that's modern software reality."</strong>
            </p>
          </div>
        </div>
      </div>
    </div>
    <!-- Slide: Team Adoption Strategies -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">ü§ù Team Adoption Strategies</h1>
        <p class="slide-subtitle">How to implement Clean and Clear Code practices successfully</p>
      </div>
      
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üå± Start Small</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Begin with <strong>one or two principles</strong> (e.g., consistent naming, shorter functions)</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Celebrate <strong>small wins</strong> ‚Äî highlight improved PRs in team meetings or retrospectives</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Avoid trying to "rewrite everything" at once; focus on incremental progress</span>
            </li>
          </ul>
        </div>
        
        <div class="content-column">
          <h2 class="column-title">üí¨ Build Consensus</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Facilitate <strong>team discussions</strong> to align on what "clean" and "clear" mean for your context</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Create and document <strong>style guides or cheat sheets</strong> so expectations are visible</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Use <strong>code reviews as learning tools</strong>, not just gatekeepers ‚Äî share why changes improve clarity or maintainability</span>
            </li>
          </ul>
        </div>
      </div>

      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßπ Apply the Boy Scout Rule</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>"Leave the code cleaner than you found it."</strong></span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Encourage small, continuous refactors whenever someone touches existing code ‚Äî no big refactor "projects" required</span>
            </li>
          </ul>
        </div>
        
        <div class="content-column">
          <h2 class="column-title">üõ†Ô∏è Use Tools to Support, Not Enforce</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Introduce linters, formatters, and static analysis gradually</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Configure tools to suggest improvements rather than block progress at first (e.g., warn instead of error)</span>
            </li>
          </ul>
        </div>
      </div>

      <div class="single-column" style="margin-top: 20px;">
        <div class="principle-card" style="background: #f7fafc; border-left: 4px solid #667eea;">
          <h3 class="principle-title">üåü Key Reminder</h3>
          <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <p style="margin: 0; font-size: 1.1rem; line-height: 1.6; color: #2d3748; font-style: italic;">
              <strong>"Adoption is a cultural change, not just technical. Consistency and shared understanding are more important than strict perfection."</strong>
            </p>
          </div>
        </div>
      </div>
    </div>
    <!-- Slide: Writing Readable Tests -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Writing Readable Tests</h1>
        <p class="slide-subtitle">Best practices from TDD, Clean Code, and Clear Code</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">1. One Assert Per Test</h3>
          <p class="principle-description">Each test should verify one behavior only. Multiple asserts can obscure
            what's being tested.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">2. Meaningful Test Names</h3>
          <p class="principle-description">Use descriptive names like `should_throw_error_when_user_not_found()` rather
            than vague ones like `testLogin()`.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">3. Arrange-Act-Assert Pattern</h3>
          <p class="principle-description">Structure each test clearly: setup (arrange), execute (act), verify (assert).
            Improves readability and debugging.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">4. Avoid Magic Numbers</h3>
          <p class="principle-description">Replace arbitrary numbers like `42` with named constants or comments
            explaining their significance.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">5. Don't Skip Edge Cases</h3>
          <p class="principle-description">Tests should cover edge cases like empty strings, nulls, and invalid
            inputs‚Äîthese are often where bugs hide.</p>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">‚ùå Poorly Written Test</div>
          <pre>test('login', () => {
  let u = new User('bob', 'pass123');
  assert(login(u));
});</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Well-Written Test</div>
          <pre>test('login_should_return_true_for_valid_credentials', () => {
  // Arrange
  const validUser = new User('alice', 'securePass!');

  // Act
  const result = login(validUser);

  // Assert
  expect(result).toBe(true);
});</pre>
        </div>
      </div>
    </div>
    <!-- Slide 14: Conclusion -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Conclusion</h1>
        <p class="slide-subtitle">Clean Code and Clear Code: Two Sides of the Same Coin</p>
      </div>

      <!-- Summary Section -->
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Key Takeaways - Clean Code</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Write code for humans first:</strong> Computers will run anything, but
                humans need clarity.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Small, focused functions:</strong> Each function should do one thing
                and do it well.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Meaningful names:</strong> Names should reveal intent and avoid
                ambiguity.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Abstraction matters:</strong> Use SOLID principles to build scalable,
                maintainable systems.</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Key Takeaways - Clear Code</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Readability over cleverness:</strong> Simple, explicit code beats smart
                tricks.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Linear flow is king:</strong> Avoid deeply nested logic; keep code
                top-to-bottom.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Minimize cognitive load:</strong> Reduce mental effort required to
                understand code.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Practical naming:</strong> Prioritize immediate comprehension over
                strict domain accuracy.</span>
            </li>
          </ul>
        </div>
      </div>

      <!-- Final Thoughts -->
      <div class="quote" style="margin-top: 40px;">
        "Clean Code emphasizes design and architecture. Clear Code focuses on readability and simplicity. The best
        developers use both."
        <div class="quote-author">‚Äî Modern Software Development Philosophy</div>
      </div>

      <!-- Closing Message -->
      <div class="single-column" style="text-align: center; margin-top: 50px;">
        <h2 style="font-size: 1.6rem; color: #333;">Final Thoughts</h2>
        <p style="font-size: 1.1rem; color: #666; max-width: 800px; margin: 0 auto; line-height: 1.6;">
          While Robert C. Martin's *Clean Code* provides a strong foundation for building robust, scalable systems,
          *Clear Code* reminds us that every line of code must be understood by humans first.
          By combining these philosophies, you can write code that is not only maintainable and extensible,
          but also easy to read, test, and modify‚Äîeven years later or by new team members.
        </p>
        <p style="font-size: 1.1rem; color: #666; margin-top: 20px;">
          Strive to write code that is clean <em>and</em> clear ‚Äî because great code serves both machines and people.
        </p>
        <div style="margin-top: 35px; color: #764ba2; font-size: 1.15rem; font-weight: 500;">
          <strong>Call to Action:</strong> I challenge everyone here: pick one principle from today‚Äîeither Clean or
          Clear‚Äîand apply it to your next code review. Then share your experience with the team!
        </div>
      </div>
    </div>
    <!-- Slide 15: References -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">References & Further Reading</h1>
        <p class="slide-subtitle">Sources that shaped our understanding of clean and clear code</p>
      </div>

      <!-- Reference Cards -->
      <div class="single-column" style="max-width: 900px; margin: 0 auto;">

        <!-- Clean Code Book -->
        <div class="principle-card" style="margin-bottom: 30px;">
          <h3 class="principle-title">üìò Clean Code: A Handbook of Agile Software Craftsmanship</h3>
          <p class="principle-description">
            By Robert C. Martin (Uncle Bob)<br>
            ISBN: 978-0132350884<br>
            This foundational book defines what clean code looks like and provides practical advice for writing
            maintainable software.
          </p>
          <a href="https://github.com/Gatjuat-Wicteat-Riek/clean-code-book/blob/master/Clean%20Code%20(%20PDFDrive.com%20).pdf"
            target="_blank" style="color: #667eea; text-decoration: none;">Github Link</a>
        </div>

        <!-- FreeCodeCamp Article -->
        <div class="principle-card" style="margin-bottom: 30px;">
          <h3 class="principle-title">üëÅÔ∏è Clear Code ‚Äì How to Write Code That Is Easy to Read</h3>
          <p class="principle-description">
            By freeCodeCamp<br>
            Published on: https://www.freecodecamp.org/news/clear-code-how-to-write-code-that-is-easy-to-read/ <br>
            Focuses on readability-first principles and practical naming, structure, and formatting techniques.
          </p>
          <a href="https://www.freecodecamp.org/news/clear-code-how-to-write-code-that-is-easy-to-read/ "
            target="_blank" style="color: #667eea; text-decoration: none;">Read Online</a>
        </div>

        <!-- Additional Resources -->
        <div class="principle-card">
          <h3 class="principle-title">üìö Additional Recommended Reading</h3>
          <ul style="list-style-type: disc; padding-left: 20px; color: #555;">
            <li><strong>Refactoring: Improving the Design of Existing Code</strong> by Martin Fowler</li>
            <li><strong>The Pragmatic Programmer</strong> by Andrew Hunt and David Thomas</li>
            <li><strong>Code Complete</strong> by Steve McConnell</li>
            <li><strong>You Don't Know JS</strong> series by Kyle Simpson (for JavaScript developers)</li>
          </ul>
        </div>

      </div>
    </div>
    <!-- Slides END -->

    <!-- Navigation Controls (Projector Style) -->
    <div class="nav-controls">
      <button class="nav-btn" id="prevBtn" onclick="navigate(-1)">Previous</button>
      <div class="slide-counter" id="slideCounter">1 / 21</div>
      <button class="nav-btn" id="nextBtn" onclick="navigate(1)">Next</button>
    </div>
    <script>
      let currentSlide = 0;
      const slides = document.querySelectorAll('.slide');
      const slideCounter = document.getElementById('slideCounter');
      const navControls = document.querySelector('.nav-controls');

      function navigate(direction) {
        slides[currentSlide].classList.remove('active');
        currentSlide += direction;
        if (currentSlide < 0) {
          currentSlide = slides.length - 1;
        } else if (currentSlide >= slides.length) {
          currentSlide = 0;
        }
        slides[currentSlide].classList.add('active');
        slideCounter.textContent = `${currentSlide + 1} / ${slides.length}`;
      }

      // Show/hide navigation controls based on cursor position
      function handleMouseMove(event) {
        const windowHeight = window.innerHeight;
        const mouseY = event.clientY;
        const bottomThreshold = windowHeight * 0.2; // Bottom 20% of screen

        if (mouseY > windowHeight - bottomThreshold) {
          navControls.style.opacity = '1';
        } else {
          navControls.style.opacity = '0';
        }
      }

      // Add mouse move listener
      document.addEventListener('mousemove', handleMouseMove);

      // Also show controls when hovering directly over them
      navControls.addEventListener('mouseenter', () => {
        navControls.style.opacity = '1';
      });

      navControls.addEventListener('mouseleave', (event) => {
        // Only hide if mouse is not in the bottom area
        const windowHeight = window.innerHeight;
        const mouseY = event.clientY;
        const bottomThreshold = windowHeight * 0.2;

        if (mouseY <= windowHeight - bottomThreshold) {
          navControls.style.opacity = '0';
        }
      });
    </script>
  </div>
  <!-- End Projector Presentation Wrapper -->
</body>

</html>