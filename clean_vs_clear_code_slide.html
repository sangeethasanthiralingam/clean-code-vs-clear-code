<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Clean Code vs. Clear Code - Technical Deep Dive</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- Projector Presentation Wrapper -->
  <div class="presentation-container">
    <!-- Slides START -->
    <!-- Slide 1: Hook Slide (NEW) -->
    <div class="slide active hook-slide">
      <div class="hook-question">
        How many of you have opened a file, looked at the code, and immediately wanted to rewrite it?
      </div>
      <div class="hook-subtitle">
        That feeling is exactly why we're here today
      </div>
      <div class="hook-stats">
        <div class="stat-card">
          <div class="stat-number">80%</div>
          <div class="stat-label">of code time is spent reading, not writing</div>
        </div>
        <div class="stat-card">
          <div class="stat-number">60%</div>
          <div class="stat-label">of bugs come from unclear requirements</div>
        </div>
        <div class="stat-card">
          <div class="stat-number">90%</div>
          <div class="stat-label">of developer frustration comes from bad code</div>
        </div>
      </div>
    </div>

    <!-- Slide 2: Title -->
    <div class="slide title-slide">
      <h1 class="slide-title">Clean Code vs. Clear Code: Finding the Right Balance</h1>
      <div class="author-info">
        <p>
          Sangeetha Santhiralingam<br>
          Software Engineer<br>
          HNDIT | Reading BSc (Hons) in Software Engineering<br>
          Presenting on: <!-- You can update the date below as needed -->
          2025-06-28
        </p>
      </div>
    </div>

    <!-- Slide 3: Martin's Quote -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">The Foundation</h1>
        <p class="slide-subtitle">What drives good code practices</p>
      </div>
      <!-- <div style="margin-bottom: 30px; text-align: center; font-size: 1.1rem; color: #764ba2;">
        <strong>Opening Hook:</strong> How many of you have opened a file, looked at the code, and immediately wanted to
        rewrite it? That feeling is exactly why we're here today.
      </div> -->
      <div class="quote">
        "Any fool can write code that a computer can understand. Good
        programmers write code that humans can understand."
        <div class="quote-author">- Robert C. Martin (Uncle Bob)</div>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßπ Clean Code Philosophy</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Code should be elegant and efficient</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Bad code tempts the mess to grow</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Clean code can be read like well-written prose</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Each function, class, and module should have a single
                responsibility</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üîç Clear Code Philosophy</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">The name should reduce any confusion about what a software
                entity does</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Immediate comprehension over architectural elegance</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Explicit over implicit behavior</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Minimize cognitive load for the reader</span>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Slide 4: Martin's Clean Code Rules -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Uncle Bob's Clean Code Rules</h1>
        <p class="slide-subtitle">Core principles from "Clean Code"</p>
      </div>
      <div style="margin-bottom: 20px; text-align: center; color: #667eea; font-size: 1.1rem;">
        <strong>Quick Poll:</strong> How many of you follow Clean Code principles strictly? (Show of hands)
      </div>
      <div class="rules-grid">
        <div class="rule-card">
          <div class="rule-number">1</div>
          <div class="rule-title">Meaningful names</div>
          <div class="rule-text">
            Use intention-revealing names. Avoid disinformation. Make
            meaningful distinctions.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">2</div>
          <div class="rule-title">Functions Should Be Small</div>
          <div class="rule-text">
            Functions should be 20 lines or fewer. Do one thing. Have no side
            effects.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">3</div>
          <div class="rule-title">Comments</div>
          <div class="rule-text">
            Don't comment bad code‚Äîrewrite it. Good code mostly documents
            itself.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">4</div>
          <div class="rule-title">Error Handling</div>
          <div class="rule-text">
            Use exceptions rather than return codes. Don't return null.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">5</div>
          <div class="rule-title">Classes</div>
          <div class="rule-text">
            Classes should be small. Single Responsibility Principle. High
            cohesion.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">6</div>
          <div class="rule-title">Systems</div>
          <div class="rule-text">
            Separate constructing a system from using it. Use dependency
            injection.
          </div>
        </div>
      </div>
    </div>

    <!-- Slide 5: Clear Code Technical Principles -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Clear Code Technical Principles</h1>
        <p class="slide-subtitle">Readability-first programming practices</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">1. Naming for Humans</h3>
          <p class="principle-description">
            Names should immediately communicate purpose without requiring
            context. Prefer `getUserAccountBalance()` over `getUAB()` or
            `calculate()`.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">2. Linear Code Flow</h3>
          <p class="principle-description">
            Code should read top-to-bottom like a newspaper. Avoid deeply
            nested conditions and callbacks that break linear comprehension.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">3. Explicit Over Clever</h3>
          <p class="principle-description">
            Prefer explicit, verbose solutions over clever one-liners. Code is
            read far more often than it's written.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">4. Consistent Formatting</h3>
          <p class="principle-description">
            Consistency in formatting improves readability. Establish a
            pattern for how you write your code, such as indentation and
            spacing.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">5. Single Level of Abstraction</h3>
          <p class="principle-description">
            Each function should operate at one level of abstraction. Don't
            mix high-level business logic with low-level implementation
            details.
          </p>
        </div>
      </div>
    </div>

    <!-- Slide 6: Naming Conventions - Technical Comparison -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Naming Conventions: Technical Examples</h1>
        <p class="slide-subtitle">Clean Code vs. Clear Code approaches</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #764ba2; font-size: 1.05rem;">
        <strong>Engagement:</strong> Before we look at the examples, who can guess which approach would prefer longer,
        more descriptive variable names?
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">
            ‚ùå Poor Naming (Both Approaches Reject)
          </div>
          <pre>
function calc(u, t) {
  return u * t * 0.1;
}

let d = new Date();
let usr = getUsr();
let flag = false;</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Clean Code Approach</div>
          <pre>
class TaxCalculator {
  calculateTax(amount: Money, rate: TaxRate): Money {
    return amount.multiply(rate.getValue());
  }
}

const taxCalculator = new TaxCalculator();
const currentDate = DateTimeProvider.now();</pre>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Clear Code Approach</div>
          <pre>
function calculateTaxAmount(orderAmount, taxRate) {
  return orderAmount * taxRate;
}

function isUserAccountActive(user) {
  return user.status === 'active' && 
         user.subscriptionEndDate > new Date();
}</pre>
        </div>
        <div class="code-example">
          <div class="code-title">Key Differences</div>
          <pre>
Clean Code:
‚Ä¢ Strong typing
‚Ä¢ Domain objects
‚Ä¢ Design patterns
‚Ä¢ Abstraction layers

Clear Code:
‚Ä¢ Descriptive names
‚Ä¢ Simple functions
‚Ä¢ Direct logic
‚Ä¢ Minimal abstraction</pre>
        </div>
      </div>
    </div>

    <!-- Slide 7: Functions - Technical Deep Dive -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Function Design: Technical Comparison</h1>
        <p class="slide-subtitle">Martin's rules vs. Clarity principles</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #764ba2; font-size: 1.05rem;">
        <strong>Exercise:</strong> Spot the difference! What stands out to you between these two code examples?
      </div>
      <div class="example-section">
        <div class="example-title">User Validation Example</div>
        <div class="code-container">
          <div class="code-example">
            <div class="code-title">
              Clean Code: Single Responsibility + Abstraction
            </div>
            <pre>
class UserValidator {
  private emailValidator: EmailValidator;
  private ageValidator: AgeValidator;
  
  validate(user: User): ValidationResult {
    const emailResult = this.emailValidator.validate(user.email);
    const ageResult = this.ageValidator.validate(user.age);
    
    return ValidationResult.combine(emailResult, ageResult);
  }
}

class EmailValidator {
  validate(email: Email): ValidationResult {
    return email.isValid() 
      ? ValidationResult.success()
      : ValidationResult.failure("Invalid email format");
  }
}</pre>
          </div>
          <div class="code-example">
            <div class="code-title">Clear Code: Direct and Explicit</div>
            <pre>
function validateUser(user) {
  const errors = [];
  
  // Check email format
  if (!user.email || !user.email.includes('@')) {
    errors.push('Email must contain @ symbol');
  }
  
  // Check age requirement
  if (!user.age || user.age < 18) {
    errors.push('User must be 18 or older');
  }
  
  // Check required fields
  if (!user.name || user.name.trim().length < 2) {
    errors.push('Name must be at least 2 characters');
  }
  
  return {
    isValid: errors.length === 0,
    errors: errors
  };
}</pre>
          </div>
        </div>
      </div>
    </div>

    <!-- Slide 8: Error Handling Patterns -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Error Handling: Technical Approaches</h1>
        <p class="slide-subtitle">Exceptions vs. explicit error handling</p>
      </div>
      <div class="code-container">
        <div class="code-example">
          <div class="code-title">Clean Code: Exception-Based</div>
          <pre>
class UserService {
  async createUser(userData: UserData): Promise&lt;User&gt; {
    try {
      const validatedData = this.validator.validate(userData);
      const user = await this.repository.save(validatedData);
      await this.emailService.sendWelcomeEmail(user);
      return user;
    } catch (ValidationError error) {
      throw new UserCreationError('Validation failed', error);
    } catch (DatabaseError error) {
      throw new UserCreationError('Database operation failed', error);
    }
  }
}</pre>
        </div>
        <div class="code-example">
          <div class="code-title">Clear Code: Explicit Return Values</div>
          <pre>
async function createUser(userData) {
  // Validate input
  const validationResult = validateUserData(userData);
  if (!validationResult.success) {
    return {
      success: false,
      error: 'Validation failed: ' + validationResult.message,
      user: null
    };
  }
  
  // Save to database
  const saveResult = await saveUserToDatabase(userData);
  if (!saveResult.success) {
    return {
      success: false,
      error: 'Failed to save user: ' + saveResult.error,
      user: null
    };
  }
  
  // Send welcome email (optional, don't fail if this fails)
  const emailResult = await sendWelcomeEmail(saveResult.user);
  if (!emailResult.success) {
    console.warn('Welcome email failed:', emailResult.error);
  }
  
  return {
    success: true,
    error: null,
    user: saveResult.user
  };
}</pre>
        </div>
      </div>
    </div>

    <!-- Slide 9: Anti-patterns and Solutions -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Common Anti-patterns</h1>
        <p class="slide-subtitle">What both approaches avoid</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #e53e3e; font-size: 1.05rem;">
        <strong>Engagement:</strong> Look at these anti-patterns - raise your hand if you've seen this in production
        code!
      </div>
      <div class="antipattern-grid">
        <div class="antipattern-card">
          <div class="antipattern-title">‚ùå God Functions</div>
          <p>
            Functions that do everything. Both approaches advocate for
            smaller, focused functions, but for different reasons.
          </p>
        </div>
        <div class="pattern-card">
          <div class="pattern-title">‚úÖ Focused Functions</div>
          <p>
            Clean Code: Single Responsibility Principle<br />Clear Code: Easy
            to understand and test
          </p>
        </div>
        <div class="antipattern-card">
          <div class="antipattern-title">‚ùå Cryptic Abbreviations</div>
          <p>
            Variables like `usr`, `calc`, `proc`. Both demand meaningful
            names, though implementation differs.
          </p>
        </div>
        <div class="pattern-card">
          <div class="pattern-title">‚úÖ Descriptive Names</div>
          <p>
            Clean Code: Domain-driven naming<br />Clear Code: Human-readable
            descriptions
          </p>
        </div>
        <div class="antipattern-card">
          <div class="antipattern-title">‚ùå Deep Nesting</div>
          <p>
            Multiple levels of if/else and loops that hurt readability and
            maintainability.
          </p>
        </div>
        <div class="pattern-card">
          <div class="pattern-title">‚úÖ Early Returns</div>
          <p>
            Guard clauses and early exits to reduce cognitive load and improve
            flow.
          </p>
        </div>
      </div>

      <!-- Code Examples Section -->
      <div style="margin-top: 30px;">
        <!-- God Functions Example -->
        <div class="example-section">
          <div class="example-title">üí• 1Ô∏è‚É£ God Functions</div>
          <div class="code-container">
            <div class="code-example code-bad">
              <div class="code-title">‚ùå Bad: God Function</div>
              <pre>
def processOrder(order):
    # validate
    if not order.items:
        print("No items")
        return
    # calculate total
    total = 0
    for item in order.items:
        total += item.price * item.quantity
    # apply discount
    if order.coupon:
        total *= 0.9
    # update inventory
    for item in order.items:
        item.stock -= item.quantity
    # send email
    print(f"Order processed. Total: ${total}")</pre>
            </div>
            <div class="code-example code-good">
              <div class="code-title">‚úÖ Good: Focused Functions</div>
              <pre>
def validateOrder(order):
    if not order.items:
        raise ValueError("No items in order")

def calculateTotal(order):
    total = sum(item.price * item.quantity for item in order.items)
    if order.coupon:
        total *= 0.9
    return total

def updateInventory(order):
    for item in order.items:
        item.stock -= item.quantity

def processOrder(order):
    validateOrder(order)
    total = calculateTotal(order)
    updateInventory(order)
    print(f"Order processed. Total: ${total}")</pre>
            </div>
          </div>
        </div>

        <!-- Cryptic Abbreviations Example -->
        <div class="example-section">
          <div class="example-title">üí• 2Ô∏è‚É£ Cryptic Abbreviations</div>
          <div class="code-container">
            <div class="code-example code-bad">
              <div class="code-title">‚ùå Bad</div>
              <pre>
def calc(p, q):
    return p * q * 0.95</pre>
            </div>
            <div class="code-example code-good">
              <div class="code-title">‚úÖ Good</div>
              <pre>
def calculateDiscountedPrice(price, quantity):
    return price * quantity * 0.95</pre>
            </div>
          </div>
        </div>

        <!-- Deep Nesting Example -->
        <div class="example-section">
          <div class="example-title">üí• 3Ô∏è‚É£ Deep Nesting</div>
          <div class="code-container">
            <div class="code-example code-bad">
              <div class="code-title">‚ùå Bad</div>
              <pre>
def processUser(user):
    if user.isActive:
        if user.hasProfile:
            if user.profile.isComplete:
                print("User is valid")</pre>
            </div>
            <div class="code-example code-good">
              <div class="code-title">‚úÖ Good (Early Returns)</div>
              <pre>
def processUser(user):
    if not user.isActive:
        return
    if not user.hasProfile:
        return
    if not user.profile.isComplete:
        return
    print("User is valid")</pre>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Slide 10: SOLID Principles Deep Dive -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">SOLID Principles in Practice</h1>
        <p class="slide-subtitle">Clean Code's architectural foundation</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">S - Single Responsibility Principle</h3>
          <p class="principle-description">
            A class should have only one reason to change. Each class should
            have only one job or responsibility.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">O - Open/Closed Principle</h3>
          <p class="principle-description">
            Software entities should be open for extension but closed for
            modification. Add new functionality without changing existing
            code.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">L - Liskov Substitution Principle</h3>
          <p class="principle-description">
            Objects of a superclass should be replaceable with objects of a
            subclass without breaking the application.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">I - Interface Segregation Principle</h3>
          <p class="principle-description">
            Clients should not be forced to depend on interfaces they don't
            use. Create specific, focused interfaces.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">D - Dependency Inversion Principle</h3>
          <p class="principle-description">
            Classes should depend upon interfaces or abstract classes instead
            of concrete classes.
          </p>
        </div>
      </div>
    </div>

    <!-- Slide 11: When to Choose Which Approach -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Decision Matrix: When to Choose Which</h1>
        <p class="slide-subtitle">Technical factors for approach selection</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #667eea; font-size: 1.05rem;">
        <strong>Reflection:</strong> Think about your current project‚Äîwhere does it fit in this matrix? What trade-offs are you currently making between readability and maintainability? (Share with your neighbor)
      </div>
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Factor</th>
            <th>Choose Clean Code When...</th>
            <th>Choose Clear Code When...</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Project Lifespan</strong></td>
            <td>Long-term (2+ years), multiple iterations</td>
            <td>Short-term scripts, prototypes, one-offs</td>
          </tr>
          <tr>
            <td><strong>Team Size</strong></td>
            <td>Large teams (5+ developers)</td>
            <td>Small teams (1-3 developers)</td>
          </tr>
          <tr>
            <td><strong>Code Complexity</strong></td>
            <td>Complex business logic, multiple domains</td>
            <td>Straightforward CRUD, minimal domain logic or business rules</td>
          </tr>
          <tr>
            <td><strong>Performance Requirements</strong></td>
            <td>Can afford abstraction overhead</td>
            <td>Need maximum performance, minimal abstraction layers and runtime overhead</td>
          </tr>
          <tr>
            <td><strong>Readability vs. Maintainability</strong></td>
            <td>Maintainability is critical</td>
            <td>Immediate understanding for current reader is paramount, even at cost of future flexibility</td>
          </tr>
          <tr>
            <td><strong>Codebase Age</strong></td>
            <td>Legacy code that needs refactoring</td>
            <td>New code that needs to be immediately understandable</td>
          </tr>
          <tr>
            <td><strong>Future Extension</strong></td>
            <td>Expect frequent feature additions or evolving requirements</td>
            <td>No significant future changes expected</td>
          </tr>
          <tr>
            <td><strong>Onboarding New Devs</strong></td>
            <td>Important to make architecture easy for new team members to understand over time</td>
            <td>Code will be used by known, small set of people who can quickly understand simpler approaches</td>
          </tr>
          <tr>
            <td><strong>Testing & Coverage</strong></td>
            <td>High automated test coverage required, needs solid structure to support testing</td>
            <td>Manual testing or throwaway code with minimal test requirements</td>
          </tr>
          <tr>
            <td><strong>Documentation Need</strong></td>
            <td>Expect thorough documentation to support longevity and handoff</td>
            <td>Documentation can be light because code is self-explanatory and short-lived</td>
          </tr>
          <tr>
            <td><strong>Regulatory/Compliance</strong></td>
            <td>Must meet compliance standards (e.g., medical, finance)</td>
            <td>No compliance or audit constraints</td>
          </tr>
        </tbody>
      </table>
    </div>
    <!-- Slide 12: Advanced Naming Techniques -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Advanced Naming Techniques</h1>
        <p class="slide-subtitle">Naming strategies from Clean Code and Clear Code</p>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code Approach</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Domain-driven names:</strong> Use business terms consistently across the whole system (e.g., `Invoice`, `calculateTaxAmount`).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Avoid abbreviations:</strong> Use full words (`customerAddress`) instead of shortcuts (`custAddr`).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Positive boolean names:</strong> Prefer affirmations like `isEligibleForDiscount()` over confusing negations.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Action verbs for functions:</strong> Start names with verbs (`get`, `set`, `find`, `validate`, `update`, `send`).</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code Approach</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Human-first names:</strong> Prioritize immediate comprehension over strict domain correctness (e.g., `getCustomerBalance()` vs. `calcCustBal()`).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Contextual clarity:</strong> Names should make sense in isolation, without needing to cross-reference other code.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Function length vs. name detail:</strong> Longer functions require more descriptive names; very short functions can be simpler.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Avoid redundant context:</strong> Don't repeat unnecessary parts (e.g., `user.getUser()` ‚Üí `user.get()`).</span>
            </li>
          </ul>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">‚ùå Poor Naming</div>
          <pre>function calc(u, t) {
  return u * t * 0.1; // What is calc? What are u and t?
}
let d = new Date();    // What does d represent?
let flag = false;      // Flag for what?</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Good Naming</div>
          <pre>function calculateTaxAmount(orderAmount, taxRate) {
  return orderAmount * taxRate;
}
const currentDate = DateTimeProvider.now();

// Clear, specific, self-explanatory</pre>
        </div>
      </div>
    </div>
    <!-- Slide 13: Functions with Fewer Side Effects -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Functions with Fewer Side Effects</h1>
        <p class="slide-subtitle">How Clean Code and Clear Code reduce unintended behavior</p>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code Perspective</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Pure functions:</strong> Always produce the same output for the same input and do not modify external state or rely on hidden inputs.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Command-Query Separation:</strong> A function should either return data OR change state‚Äînever both.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Avoid global variables:</strong> Prevent unpredictable dependencies and bugs by avoiding global or static state.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Testable design:</strong> Pure, side-effect-free functions are easier to test and reason about.</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code Perspective</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Explicit behavior:</strong> Use clear names to signal side effects (e.g., `saveUser()` clearly implies a write action).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Minimize mutation:</strong> Return new objects instead of changing arguments directly whenever possible.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Read-only functions:</strong> Prefer functions that only read and return data; they are safer and easier to understand.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Single action per function:</strong> Split functions with multiple side effects into smaller, more focused ones.</span>
            </li>
          </ul>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">‚ùå Bad Example</div>
          <pre>function updateCart(cart, item) {
  cart.items.push(item);
  cart.total += item.price;
}

// ‚ö†Ô∏è Directly mutates cart, making state management 
// and debugging harder.</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Good Example</div>
          <pre>function addItemToCart(cart, item) {
  const newItems = [...cart.items, item];
  const newTotal = cart.total + item.price;
  return { ...cart, items: newItems, total: newTotal };
}

// ‚úÖ Creates and returns a new cart object without 
// mutating the original; easier to test and predict.</pre>
        </div>
      </div>
    </div>
    <!-- Slide: Performance Impact -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Performance Impact</h1>
        <p class="slide-subtitle">How Clean and Clear Code affect speed and resources</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">Abstraction vs. Directness</h3>
          <p class="principle-description">Clean Code may introduce abstraction layers (e.g., design patterns, domain
            objects) that can add minor overhead, while Clear Code often favors direct logic for speed. For most
            business apps, the difference is negligible, but in performance-critical code (e.g., game loops, data
            processing), minimalism can matter.</p>
        </div>
        <!-- <div class="principle-card">
      <h3 class="principle-title">Speaker Cue</h3>
      <p class="principle-description"><em>Ask:</em> "Has anyone here ever had to refactor code for performance? What trade-offs did you make?"</p>
    </div> -->
      </div>
    </div>
    <!-- Slide: Hybrid Approach -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Hybrid Approach: Best of Both Worlds</h1>
        <p class="slide-subtitle">When to combine Clean and Clear Code</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">Practical Example</h3>
          <pre
            style="background:#2d3748;color:#e2e8f0;padding:15px;border-radius:8px;font-size:0.95rem;overflow-x:auto;"><code>class UserService {
  // Clean Code: Strong typing and single responsibility
  async createUserAccount(userData: CreateUserRequest): Promise<UserCreationResult> {
    // Clear Code: Explicit step-by-step logic
    const validationErrors = this.validateUserData(userData);
    if (validationErrors.length > 0) {
      return { success: false, errors: validationErrors };
    }
    const newUser = await this.saveUserToDatabase(userData);
    await this.sendWelcomeEmail(newUser);
    return { success: true, user: newUser };
  }
}</code></pre>
        </div>
        <!-- <div class="principle-card">
      <h3 class="principle-title">Speaker Note</h3>
      <p class="principle-description">"Most real-world codebases blend both philosophies. The key is knowing when to optimize for clarity and when for maintainability."</p>
    </div> -->
      </div>
    </div>
    <!-- Slide: FAQ & Migration Strategies -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">FAQ & Migration Strategies</h1>
        <p class="slide-subtitle">Addressing common concerns and transitions</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">Q: What if my team prefers one style?</h3>
          <p class="principle-description">A: Align on shared guidelines, but allow flexibility for context. Document
            your decisions.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">Q: How do we migrate legacy code?</h3>
          <p class="principle-description">A: Refactor incrementally. Start with new features and high-churn areas. Use
            tests to ensure safety.</p>
        </div>
        <!-- <div class="principle-card">
      <h3 class="principle-title">Speaker Note</h3>
      <p class="principle-description">"Invite questions from the audience‚Äîwhat's your biggest codebase pain point?"</p>
    </div> -->
      </div>
    </div>
    <!-- Slide: Tooling & IDE Support -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Tooling & IDE Support</h1>
        <p class="slide-subtitle">How tools help enforce Clean and Clear Code</p>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code Tools</h2>
          <ul class="feature-list">
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Linters (ESLint,
                Pylint, etc.)</span></li>
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Static analysis
                (SonarQube, CodeClimate)</span></li>
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Refactoring tools (IDE
                built-ins, Resharper)</span></li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code Tools</h2>
          <ul class="feature-list">
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Auto-formatters
                (Prettier, Black, gofmt)</span></li>
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Naming suggestions
                (IntelliSense, Copilot)</span></li>
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Readability plugins
                (Code Spell Checker, Highlight Matching Tag)</span></li>
          </ul>
        </div>
      </div>
      <div class="single-column" style="margin-top:20px;">
        <!-- <div class="principle-card">
      <h3 class="principle-title">Speaker Note</h3>
      <p class="principle-description">"Demo: Show how a linter or formatter can catch issues live in your IDE."</p>
    </div> -->
      </div>
    </div>
    <!-- Slide: Real-World Case Study -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Real-World Case Study</h1>
        <p class="slide-subtitle">Comparing both approaches on a real feature</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">Feature: User Registration</h3>
          <p class="principle-description">Show the same feature implemented in both Clean Code (modular, abstracted)
            and Clear Code (direct, explicit) styles. Discuss trade-offs in readability, maintainability, and
            onboarding.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">Interactive Cue</h3>
          <p class="principle-description">"Ask the audience: Which version would you prefer to maintain? Why?"</p>
        </div>
      </div>
    </div>
    <!-- Slide: Industry Examples -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Industry Examples</h1>
        <p class="slide-subtitle">How major companies apply these principles</p>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code in the Wild</h2>
          <ul class="feature-list">
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Google: Strict code
                reviews, style guides, SOLID principles</span></li>
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Microsoft: Emphasis on
                maintainability for large teams</span></li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code in the Wild</h2>
          <ul class="feature-list">
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Startups: Fast
                prototyping, direct logic, minimal abstraction</span></li>
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Open source:
                Readability prioritized for contributors</span></li>
          </ul>
        </div>
      </div>
      <div class="single-column" style="margin-top:20px;">
        <!-- <div class="principle-card">
      <h3 class="principle-title">Speaker Note</h3>
      <p class="principle-description">"Highlight: No one-size-fits-all. Even big companies adapt their style to the project and team."</p>
    </div> -->
      </div>
    </div>
    <!-- Slide: Team Adoption Strategies -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Team Adoption Strategies</h1>
        <p class="slide-subtitle">How to implement Clean and Clear Code practices</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">Start Small</h3>
          <p class="principle-description">Adopt one or two principles at a time. Celebrate small wins and improvements.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">Build Consensus</h3>
          <p class="principle-description">Discuss as a team, document your standards, and review code together.</p>
        </div>
        <!-- <div class="principle-card">
      <h3 class="principle-title">Speaker Note</h3>
      <p class="principle-description">"Encourage: Share a story of a successful team transition or ask the audience for theirs."</p>
    </div> -->
      </div>
    </div>
    <!-- Slide: Measuring Code Quality -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Measuring Code Quality</h1>
        <p class="slide-subtitle">Metrics for Clean and Clear Code</p>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code Metrics</h2>
          <ul class="feature-list">
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Cyclomatic
                complexity</span></li>
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Code coverage</span>
            </li>
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Number of code
                smells</span></li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code Metrics</h2>
          <ul class="feature-list">
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Readability scores
                (e.g., comment/code ratio)</span></li>
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">Time to onboard new
                devs</span></li>
            <li class="feature-item"><span class="feature-icon"></span><span class="feature-text">PR review time</span>
            </li>
          </ul>
        </div>
      </div>
      <div class="single-column" style="margin-top:20px;">
        <!-- <div class="principle-card">
      <h3 class="principle-title">Speaker Note</h3>
      <p class="principle-description">"Ask: What metrics does your team use? Are they working for you?"</p>
    </div> -->
      </div>
    </div>
    <!-- Slide 13: Writing Readable Tests -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Writing Readable Tests</h1>
        <p class="slide-subtitle">Best practices from TDD, Clean Code, and Clear Code</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">1. One Assert Per Test</h3>
          <p class="principle-description">Each test should verify one behavior only. Multiple asserts can obscure
            what's being tested.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">2. Meaningful Test Names</h3>
          <p class="principle-description">Use descriptive names like `should_throw_error_when_user_not_found()` rather
            than vague ones like `testLogin()`.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">3. Arrange-Act-Assert Pattern</h3>
          <p class="principle-description">Structure each test clearly: setup (arrange), execute (act), verify (assert).
            Improves readability and debugging.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">4. Avoid Magic Numbers</h3>
          <p class="principle-description">Replace arbitrary numbers like `42` with named constants or comments
            explaining their significance.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">5. Don't Skip Edge Cases</h3>
          <p class="principle-description">Tests should cover edge cases like empty strings, nulls, and invalid
            inputs‚Äîthese are often where bugs hide.</p>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">‚ùå Poorly Written Test</div>
          <pre>test('login', () => {
  let u = new User('bob', 'pass123');
  assert(login(u));
});</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Well-Written Test</div>
          <pre>test('login_should_return_true_for_valid_credentials', () => {
  // Arrange
  const validUser = new User('alice', 'securePass!');

  // Act
  const result = login(validUser);

  // Assert
  expect(result).toBe(true);
});</pre>
        </div>
      </div>
    </div>
    <!-- Slide 14: Conclusion -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Conclusion</h1>
        <p class="slide-subtitle">Clean Code and Clear Code: Two Sides of the Same Coin</p>
      </div>

      <!-- Summary Section -->
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Key Takeaways - Clean Code</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Write code for humans first:</strong> Computers will run anything, but
                humans need clarity.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Small, focused functions:</strong> Each function should do one thing
                and do it well.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Meaningful names:</strong> Names should reveal intent and avoid
                ambiguity.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Abstraction matters:</strong> Use SOLID principles to build scalable,
                maintainable systems.</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Key Takeaways - Clear Code</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Readability over cleverness:</strong> Simple, explicit code beats smart
                tricks.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Linear flow is king:</strong> Avoid deeply nested logic; keep code
                top-to-bottom.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Minimize cognitive load:</strong> Reduce mental effort required to
                understand code.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Practical naming:</strong> Prioritize immediate comprehension over
                strict domain accuracy.</span>
            </li>
          </ul>
        </div>
      </div>

      <!-- Final Thoughts -->
      <div class="quote" style="margin-top: 40px;">
        "Clean Code emphasizes design and architecture. Clear Code focuses on readability and simplicity. The best
        developers use both."
        <div class="quote-author">‚Äî Modern Software Development Philosophy</div>
      </div>

      <!-- Closing Message -->
      <div class="single-column" style="text-align: center; margin-top: 50px;">
        <h2 style="font-size: 1.6rem; color: #333;">Final Thoughts</h2>
        <p style="font-size: 1.1rem; color: #666; max-width: 800px; margin: 0 auto; line-height: 1.6;">
          While Robert C. Martin's *Clean Code* provides a strong foundation for building robust, scalable systems,
          *Clear Code* reminds us that every line of code must be understood by humans first.
          By combining these philosophies, you can write code that is not only maintainable and extensible,
          but also easy to read, test, and modify‚Äîeven years later or by new team members.
        </p>
        <p style="font-size: 1.1rem; color: #666; margin-top: 20px;">
          Strive to write code that is clean <em>and</em> clear ‚Äî because great code serves both machines and people.
        </p>
        <div style="margin-top: 35px; color: #764ba2; font-size: 1.15rem; font-weight: 500;">
          <strong>Call to Action:</strong> I challenge everyone here: pick one principle from today‚Äîeither Clean or
          Clear‚Äîand apply it to your next code review. Then share your experience with the team!
        </div>
      </div>
    </div>
    <!-- Slide 15: References -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">References & Further Reading</h1>
        <p class="slide-subtitle">Sources that shaped our understanding of clean and clear code</p>
      </div>

      <!-- Reference Cards -->
      <div class="single-column" style="max-width: 900px; margin: 0 auto;">

        <!-- Clean Code Book -->
        <div class="principle-card" style="margin-bottom: 30px;">
          <h3 class="principle-title">üìò Clean Code: A Handbook of Agile Software Craftsmanship</h3>
          <p class="principle-description">
            By Robert C. Martin (Uncle Bob)<br>
            ISBN: 978-0132350884<br>
            This foundational book defines what clean code looks like and provides practical advice for writing
            maintainable software.
          </p>
          <a href="https://github.com/Gatjuat-Wicteat-Riek/clean-code-book/blob/master/Clean%20Code%20(%20PDFDrive.com%20).pdf"
            target="_blank" style="color: #667eea; text-decoration: none;">Github Link</a>
        </div>

        <!-- FreeCodeCamp Article -->
        <div class="principle-card" style="margin-bottom: 30px;">
          <h3 class="principle-title">üëÅÔ∏è Clear Code ‚Äì How to Write Code That Is Easy to Read</h3>
          <p class="principle-description">
            By freeCodeCamp<br>
            Published on: https://www.freecodecamp.org/news/clear-code-how-to-write-code-that-is-easy-to-read/ <br>
            Focuses on readability-first principles and practical naming, structure, and formatting techniques.
          </p>
          <a href="https://www.freecodecamp.org/news/clear-code-how-to-write-code-that-is-easy-to-read/ "
            target="_blank" style="color: #667eea; text-decoration: none;">Read Online</a>
        </div>

        <!-- Additional Resources -->
        <div class="principle-card">
          <h3 class="principle-title">üìö Additional Recommended Reading</h3>
          <ul style="list-style-type: disc; padding-left: 20px; color: #555;">
            <li><strong>Refactoring: Improving the Design of Existing Code</strong> by Martin Fowler</li>
            <li><strong>The Pragmatic Programmer</strong> by Andrew Hunt and David Thomas</li>
            <li><strong>Code Complete</strong> by Steve McConnell</li>
            <li><strong>You Don't Know JS</strong> series by Kyle Simpson (for JavaScript developers)</li>
          </ul>
        </div>

      </div>
    </div>
    <!-- Slides END -->

    <!-- Navigation Controls (Projector Style) -->
    <div class="nav-controls">
      <button class="nav-btn" id="prevBtn" onclick="navigate(-1)">Previous</button>
      <div class="slide-counter" id="slideCounter">1 / 24</div>
      <button class="nav-btn" id="nextBtn" onclick="navigate(1)">Next</button>
    </div>
    <script>
      let currentSlide = 0;
      const slides = document.querySelectorAll('.slide');
      const slideCounter = document.getElementById('slideCounter');
      const navControls = document.querySelector('.nav-controls');

      function navigate(direction) {
        slides[currentSlide].classList.remove('active');
        currentSlide += direction;
        if (currentSlide < 0) {
          currentSlide = slides.length - 1;
        } else if (currentSlide >= slides.length) {
          currentSlide = 0;
        }
        slides[currentSlide].classList.add('active');
        slideCounter.textContent = `${currentSlide + 1} / ${slides.length}`;
      }

      // Show/hide navigation controls based on cursor position
      function handleMouseMove(event) {
        const windowHeight = window.innerHeight;
        const mouseY = event.clientY;
        const bottomThreshold = windowHeight * 0.2; // Bottom 20% of screen

        if (mouseY > windowHeight - bottomThreshold) {
          navControls.style.opacity = '1';
        } else {
          navControls.style.opacity = '0';
        }
      }

      // Add mouse move listener
      document.addEventListener('mousemove', handleMouseMove);

      // Also show controls when hovering directly over them
      navControls.addEventListener('mouseenter', () => {
        navControls.style.opacity = '1';
      });

      navControls.addEventListener('mouseleave', (event) => {
        // Only hide if mouse is not in the bottom area
        const windowHeight = window.innerHeight;
        const mouseY = event.clientY;
        const bottomThreshold = windowHeight * 0.2;

        if (mouseY <= windowHeight - bottomThreshold) {
          navControls.style.opacity = '0';
        }
      });
    </script>
  </div>
  <!-- End Projector Presentation Wrapper -->
</body>

</html>