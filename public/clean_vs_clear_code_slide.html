<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Clean Code vs. Clear Code - Technical Deep Dive</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- Projector Presentation Wrapper -->
  <div class="presentation-container">
    <!-- Slides START -->
    <!-- Slide 1: Hook Slide (NEW) -->
    <div class="slide active hook-slide">
      <div class="hook-question">
        How many of you have opened a file, looked at the code, and immediately wanted to rewrite it?
      </div>
      <div class="hook-subtitle">
        That feeling is exactly why we're here today
      </div>
      <div class="hook-stats">
        <div class="stat-card">
          <div class="stat-number">80%</div>
          <div class="stat-label">of code time is spent reading, not writing</div>
        </div>
        <div class="stat-card">
          <div class="stat-number">60%</div>
          <div class="stat-label">of bugs come from unclear requirements</div>
        </div>
        <div class="stat-card">
          <div class="stat-number">90%</div>
          <div class="stat-label">of developer frustration comes from bad code</div>
        </div>
      </div>
    </div>

    <!-- Slide 2: Title -->
    <div class="slide title-slide">
      <h1 class="slide-title">Clean Code vs. Clear Code: Finding the Right Balance</h1>
      <div class="author-info">
        <p>
          Sangeetha Santhiralingam<br>
          Software Engineer<br>
          HNDIT | Reading BSc (Hons) in Software Engineering<br>
          Presenting on: <!-- You can update the date below as needed -->
          2025-07-04
        </p>
      </div>
      <div style="text-align:center; margin-top: 30px;">
        <a href="feature_aspect_comparison.html"
          style="display:inline-block; background:#667eea; color:white; font-size:1.15rem; padding:12px 28px; border-radius:6px; text-decoration:none; font-weight:600; box-shadow:0 2px 8px rgba(102,126,234,0.10); transition:background 0.2s;">Compare
          Code Qualities &rarr;</a>
      </div>
    </div>

    <!-- Slide 3: Martin's Quote -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">The Foundation</h1>
        <p class="slide-subtitle">What drives good code practices</p>
      </div>
      <!-- <div style="margin-bottom: 30px; text-align: center; font-size: 1.1rem; color: #764ba2;">
        <strong>Opening Hook:</strong> How many of you have opened a file, looked at the code, and immediately wanted to
        rewrite it? That feeling is exactly why we're here today.
      </div> -->
      <div class="quote">
        "Any fool can write code that a computer can understand. Good programmers write code that humans can
        understand."
        <div class="quote-author">- Martin Fowler</div>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßπ Clean Code Philosophy</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Code should be elegant and efficient</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Bad code tempts the mess to grow</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Clean code can be read like well-written prose</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Each function, class, and module should have a single
                responsibility</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üîç Clear Code Philosophy</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">The name should reduce any confusion about what a software
                entity does</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Immediate comprehension over architectural elegance</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Explicit over implicit behavior</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text">Minimize cognitive load for the reader</span>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Slide 4: Martin's Clean Code Rules -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Uncle Bob's Clean Code Rules</h1>
        <p class="slide-subtitle">Core principles from "Clean Code"</p>
      </div>
      <div style="margin-bottom: 20px; text-align: center; color: #667eea; font-size: 1.1rem;">
        <strong>Quick Poll:</strong> How many of you follow Clean Code principles strictly? (Show of hands)
      </div>
      <div class="rules-grid">
        <div class="rule-card">
          <div class="rule-number">1</div>
          <div class="rule-title">Meaningful names</div>
          <div class="rule-text">
            Use intention-revealing names. Avoid disinformation. Make
            meaningful distinctions.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">2</div>
          <div class="rule-title">Functions Should Be Small</div>
          <div class="rule-text">
            Functions should be 20 lines or fewer. Do one thing. Have no side
            effects.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">3</div>
          <div class="rule-title">Comments</div>
          <div class="rule-text">
            Don't comment bad code‚Äîrewrite it. Good code mostly documents
            itself.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">4</div>
          <div class="rule-title">Error Handling</div>
          <div class="rule-text">
            Use exceptions rather than return codes. Don't return null.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">5</div>
          <div class="rule-title">Classes</div>
          <div class="rule-text">
            Classes should be small. Single Responsibility Principle. High
            cohesion.
          </div>
        </div>
        <div class="rule-card">
          <div class="rule-number">6</div>
          <div class="rule-title">Systems</div>
          <div class="rule-text">
            Separate constructing a system from using it. Use dependency
            injection.
          </div>
        </div>
      </div>
    </div>

    <!-- Slide 5: Clear Code Technical Principles -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Clear Code Technical Principles</h1>
        <p class="slide-subtitle">Readability-first programming practices</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">1. Naming for Humans</h3>
          <p class="principle-description">
            Names should immediately communicate purpose without requiring
            context. Prefer `getUserAccountBalance()` over `getUAB()` or
            `calculate()`.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">2. Linear Code Flow</h3>
          <p class="principle-description">
            Code should read top-to-bottom like a newspaper. Avoid deeply
            nested conditions and callbacks that break linear comprehension.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">3. Explicit Over Clever</h3>
          <p class="principle-description">
            Prefer explicit, verbose solutions over clever one-liners. Code is
            read far more often than it's written.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">4. Consistent Formatting</h3>
          <p class="principle-description">
            Consistency in formatting improves readability. Establish a
            pattern for how you write your code, such as indentation and
            spacing.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">5. Single Level of Abstraction</h3>
          <p class="principle-description">
            Each function should operate at one level of abstraction. Don't
            mix high-level business logic with low-level implementation
            details.
          </p>
        </div>
      </div>
    </div>

    <!-- Slide 6: Naming Conventions - Technical Comparison -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Naming Conventions: Technical Examples</h1>
        <p class="slide-subtitle">Clean Code vs. Clear Code approaches</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #764ba2; font-size: 1.05rem;">
        <strong>Engagement:</strong> Before we look at the examples, who can guess which approach would prefer longer,
        more descriptive variable names?
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">
            ‚ùå Poor Naming (Both Approaches Reject)
          </div>
          <pre>
function calc(u, t) {
  return u * t * 0.1;
}

let d = new Date();
let usr = getUsr();
let flag = false;</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Clean Code Approach</div>
          <pre>
class TaxCalculator {
  calculateTax(amount: Money, rate: TaxRate): Money {
    return amount.multiply(rate.getValue());
  }
}

const taxCalculator = new TaxCalculator();
const currentDate = DateTimeProvider.now();</pre>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Clear Code Approach</div>
          <pre>
function calculateTaxAmount(orderAmount, taxRate) {
  return orderAmount * taxRate;
}

function isUserAccountActive(user) {
  return user.status === 'active' && 
         user.subscriptionEndDate > new Date();
}</pre>
        </div>
        <div class="code-example">
          <div class="code-title">Key Differences</div>
          <pre>
Clean Code:
‚Ä¢ Strong typing
‚Ä¢ Domain objects
‚Ä¢ Design patterns
‚Ä¢ Abstraction layers

Clear Code:
‚Ä¢ Descriptive names
‚Ä¢ Simple functions
‚Ä¢ Direct logic
‚Ä¢ Minimal abstraction</pre>
        </div>
      </div>
    </div>

    <!-- Slide 7: Functions - Technical Deep Dive -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Function Design: Technical Comparison</h1>
        <p class="slide-subtitle">Martin's rules vs. Clarity principles</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #764ba2; font-size: 1.05rem;">
        <strong>Exercise:</strong> Spot the difference! What stands out to you between these two code examples?
      </div>
      <div class="example-section">
        <div class="example-title">User Validation Example</div>
        <div class="code-container">
          <div class="code-example">
            <div class="code-title">
              Clean Code: Single Responsibility + Abstraction
            </div>
            <pre>
class UserValidator {
  private emailValidator: EmailValidator;
  private ageValidator: AgeValidator;
  
  validate(user: User): ValidationResult {
    const emailResult = this.emailValidator.validate(user.email);
    const ageResult = this.ageValidator.validate(user.age);
    
    return ValidationResult.combine(emailResult, ageResult);
  }
}

class EmailValidator {
  validate(email: Email): ValidationResult {
    return email.isValid() 
      ? ValidationResult.success()
      : ValidationResult.failure("Invalid email format");
  }
}</pre>
          </div>
          <div class="code-example">
            <div class="code-title">Clear Code: Direct and Explicit</div>
            <pre>
function validateUser(user) {
  const errors = [];
  
  // Check email format
  if (!user.email || !user.email.includes('@')) {
    errors.push('Email must contain @ symbol');
  }
  
  // Check age requirement
  if (!user.age || user.age < 18) {
    errors.push('User must be 18 or older');
  }
  
  // Check required fields
  if (!user.name || user.name.trim().length < 2) {
    errors.push('Name must be at least 2 characters');
  }
  
  return {
    isValid: errors.length === 0,
    errors: errors
  };
}</pre>
          </div>
        </div>
      </div>
    </div>

    <!-- Slide 8: Error Handling Patterns -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Error Handling: Technical Approaches</h1>
        <p class="slide-subtitle">Exceptions vs. explicit error handling</p>
      </div>
      <div class="code-container">
        <div class="code-example">
          <div class="code-title">Clean Code: Exception-Based</div>
          <pre>
class UserService {
  async createUser(userData: UserData): Promise&lt;User&gt; {
    try {
      const validatedData = this.validator.validate(userData);
      const user = await this.repository.save(validatedData);
      await this.emailService.sendWelcomeEmail(user);
      return user;
    } catch (ValidationError error) {
      throw new UserCreationError('Validation failed', error);
    } catch (DatabaseError error) {
      throw new UserCreationError('Database operation failed', error);
    }
  }
}</pre>
        </div>
        <div class="code-example">
          <div class="code-title">Clear Code: Explicit Return Values</div>
          <pre>
async function createUser(userData) {
  // Validate input
  const validationResult = validateUserData(userData);
  if (!validationResult.success) {
    return {
      success: false,
      error: 'Validation failed: ' + validationResult.message,
      user: null
    };
  }
  
  // Save to database
  const saveResult = await saveUserToDatabase(userData);
  if (!saveResult.success) {
    return {
      success: false,
      error: 'Failed to save user: ' + saveResult.error,
      user: null
    };
  }
  
  // Send welcome email (optional, don't fail if this fails)
  const emailResult = await sendWelcomeEmail(saveResult.user);
  if (!emailResult.success) {
    console.warn('Welcome email failed:', emailResult.error);
  }
  
  return {
    success: true,
    error: null,
    user: saveResult.user
  };
}</pre>
        </div>
      </div>
    </div>

    <!-- Slide 9: Anti-patterns and Solutions -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Common Anti-patterns</h1>
        <p class="slide-subtitle">What both approaches avoid</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #e53e3e; font-size: 1.05rem;">
        <strong>Engagement:</strong> Look at these anti-patterns - raise your hand if you've seen this in production
        code!
      </div>
      <div class="antipattern-grid">
        <div class="antipattern-card">
          <div class="antipattern-title">‚ùå God Functions</div>
          <p>
            Functions that do everything. Both approaches advocate for
            smaller, focused functions, but for different reasons.
          </p>
        </div>
        <div class="pattern-card">
          <div class="pattern-title">‚úÖ Focused Functions</div>
          <p>
            Clean Code: Single Responsibility Principle<br />Clear Code: Easy
            to understand and test
          </p>
        </div>
        <div class="antipattern-card">
          <div class="antipattern-title">‚ùå Cryptic Abbreviations</div>
          <p>
            Variables like `usr`, `calc`, `proc`. Both demand meaningful
            names, though implementation differs.
          </p>
        </div>
        <div class="pattern-card">
          <div class="pattern-title">‚úÖ Descriptive Names</div>
          <p>
            Clean Code: Domain-driven naming<br />Clear Code: Human-readable
            descriptions
          </p>
        </div>
        <div class="antipattern-card">
          <div class="antipattern-title">‚ùå Deep Nesting</div>
          <p>
            Multiple levels of if/else and loops that hurt readability and
            maintainability.
          </p>
        </div>
        <div class="pattern-card">
          <div class="pattern-title">‚úÖ Early Returns</div>
          <p>
            Guard clauses and early exits to reduce cognitive load and improve
            flow.
          </p>
        </div>
      </div>

      <!-- Code Examples Section -->
      <div style="margin-top: 30px;">
        <!-- God Functions Example -->
        <div class="example-section">
          <div class="example-title">üí• 1Ô∏è‚É£ God Functions</div>
          <div class="code-container">
            <div class="code-example code-bad">
              <div class="code-title">‚ùå Bad: God Function</div>
              <pre>
def processOrder(order):
    # validate
    if not order.items:
        print("No items")
        return
    # calculate total
    total = 0
    for item in order.items:
        total += item.price * item.quantity
    # apply discount
    if order.coupon:
        total *= 0.9
    # update inventory
    for item in order.items:
        item.stock -= item.quantity
    # send email
    print(f"Order processed. Total: ${total}")</pre>
            </div>
            <div class="code-example code-good">
              <div class="code-title">‚úÖ Good: Focused Functions</div>
              <pre>
def validateOrder(order):
    if not order.items:
        raise ValueError("No items in order")

def calculateTotal(order):
    total = sum(item.price * item.quantity for item in order.items)
    if order.coupon:
        total *= 0.9
    return total

def updateInventory(order):
    for item in order.items:
        item.stock -= item.quantity

def processOrder(order):
    validateOrder(order)
    total = calculateTotal(order)
    updateInventory(order)
    print(f"Order processed. Total: ${total}")</pre>
            </div>
          </div>
        </div>

        <!-- Cryptic Abbreviations Example -->
        <div class="example-section">
          <div class="example-title">üí• 2Ô∏è‚É£ Cryptic Abbreviations</div>
          <div class="code-container">
            <div class="code-example code-bad">
              <div class="code-title">‚ùå Bad</div>
              <pre>
def calc(p, q):
    return p * q * 0.95</pre>
            </div>
            <div class="code-example code-good">
              <div class="code-title">‚úÖ Good</div>
              <pre>
def calculateDiscountedPrice(price, quantity):
    return price * quantity * 0.95</pre>
            </div>
          </div>
        </div>

        <!-- Deep Nesting Example -->
        <div class="example-section">
          <div class="example-title">üí• 3Ô∏è‚É£ Deep Nesting</div>
          <div class="code-container">
            <div class="code-example code-bad">
              <div class="code-title">‚ùå Bad</div>
              <pre>
def processUser(user):
    if user.isActive:
        if user.hasProfile:
            if user.profile.isComplete:
                print("User is valid")</pre>
            </div>
            <div class="code-example code-good">
              <div class="code-title">‚úÖ Good (Early Returns)</div>
              <pre>
def processUser(user):
    if not user.isActive:
        return
    if not user.hasProfile:
        return
    if not user.profile.isComplete:
        return
    print("User is valid")</pre>
            </div>
          </div>
        </div>
      </div>
      <!-- Mermaid Diagram: Code Quality Anti-Patterns Flow -->
      <div style="margin: 32px 0; text-align: center;">
        <h3 style="color: #764ba2; margin-bottom: 10px;">
          How Anti-Patterns, Code Smells, and Technical Debt Interconnect
        </h3>
        <a href="https://mermaid.live/edit#pako:eNqdlG1vmzAQx7-K5RdRJyVdE0hCmDSpgVSKtIduSTVppC8cOMCqsZltsmZVv_sOSBr2UKkqEuIM_v3_Z_uOBxqrBKhPM83KnKzDjSR4XUYfWHxHVEpCbmJeCi6BvCXXSmkSguGZxEfMDVfS3JLB4D2ZnwUoRFYFCGHIgKz2RWlVYUiPLGXCY2aVNm_eHeQbJDi7lJYPrpm1oGUNLSWkKcSW71BJicrW-jXUYvMGC6MbWTAuLd5sK4A0xut9Ceb2oB-0E5_AsBkvok-QsUa8Qb5UTHDLW-zo0EO4h0CPLBroKrqM46qoBLOQkDXEucTFCFz-1mLG67wWM_b2Dy-yoUsZiyoBQ-DeaiiApErjbgh-BxvapjeMViXLcrCWNwkds3-5wij6ynZcidfyTvRNcwuDz1Ls_ycRMEkEsIRYdURcrAwDGksBTwCfR6rlFn9Z5-onqQuMbCFnOzAHlcUwutIs44fDO7q-lMZl84wnr2KdaFkUatu1bgVMtW17IFAayNKYCqHmS1OxbQgy-Wf-teYF03vykUmegrGsqdoTOj-FwfMqqxL7KeUxyiks6gJV4rZMV1ZXsa10N52wEw478agTO53Yfd54Xu8PVxprOsC84UcFMu56LTphx2vR8Vo4z-vXHXIjLO6RbVvlhF09UbSPPyCeUB_XCn1agMYOxyF9qKdsqM2xgDfUxzCBlFXCbuhGPiJWMvldqeJIalVlOfVTJgyOqjJB15AzTOU0Bf1AB6qSlvrjRoH6D_Se-gPnwvPOJ-PJdDq-8EbO2PP6dI_vvaFzPryYjYbubDqaON5jn_5qTN1z1505w8ls6rljdzx7_A0Igpm8" target="_blank">
    <img src="https://mermaid.ink/img/pako:eNqdlG1vmzAQx7-K5RdRJyVdE0hCmDSpgVSKtIduSTVppC8cOMCqsZltsmZVv_sOSBr2UKkqEuIM_v3_Z_uOBxqrBKhPM83KnKzDjSR4XUYfWHxHVEpCbmJeCi6BvCXXSmkSguGZxEfMDVfS3JLB4D2ZnwUoRFYFCGHIgKz2RWlVYUiPLGXCY2aVNm_eHeQbJDi7lJYPrpm1oGUNLSWkKcSW71BJicrW-jXUYvMGC6MbWTAuLd5sK4A0xut9Ceb2oB-0E5_AsBkvok-QsUa8Qb5UTHDLW-zo0EO4h0CPLBroKrqM46qoBLOQkDXEucTFCFz-1mLG67wWM_b2Dy-yoUsZiyoBQ-DeaiiApErjbgh-BxvapjeMViXLcrCWNwkds3-5wij6ynZcidfyTvRNcwuDz1Ls_ycRMEkEsIRYdURcrAwDGksBTwCfR6rlFn9Z5-onqQuMbCFnOzAHlcUwutIs44fDO7q-lMZl84wnr2KdaFkUatu1bgVMtW17IFAayNKYCqHmS1OxbQgy-Wf-teYF03vykUmegrGsqdoTOj-FwfMqqxL7KeUxyiks6gJV4rZMV1ZXsa10N52wEw478agTO53Yfd54Xu8PVxprOsC84UcFMu56LTphx2vR8Vo4z-vXHXIjLO6RbVvlhF09UbSPPyCeUB_XCn1agMYOxyF9qKdsqM2xgDfUxzCBlFXCbuhGPiJWMvldqeJIalVlOfVTJgyOqjJB15AzTOU0Bf1AB6qSlvrjRoH6D_Se-gPnwvPOJ-PJdDq-8EbO2PP6dI_vvaFzPryYjYbubDqaON5jn_5qTN1z1505w8ls6rljdzx7_A0Igpm8?type=png"
         alt="How Anti-Patterns, Code Smells, and Technical Debt Interconnect"
         style="max-width:100%;border-radius:8px;box-shadow:0 2px 8px rgba(102,126,234,0.10);margin-bottom:12px;">
  </a>
  <div style="font-size: 0.95rem; color: #666; margin-top: 8px; max-width: 700px; margin-left: auto; margin-right: auto;">
    This diagram shows how poor design choices and lack of discipline lead to code smells and anti-patterns, which
    manifest as unmaintainable code and negative qualities, ultimately resulting in technical debt.
  </div>
</div>
      <!-- End Mermaid Diagram -->

      <!-- Mermaid JS initialization (must include once in your page) -->
      <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
      </script>

    </div>

    <!-- Slide 10: SOLID Principles Deep Dive -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">SOLID Principles in Practice</h1>
        <p class="slide-subtitle">Clean Code's architectural foundation</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">S - Single Responsibility Principle</h3>
          <p class="principle-description">
            A class should have only one reason to change. Each class should
            have only one job or responsibility.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">O - Open/Closed Principle</h3>
          <p class="principle-description">
            Software entities should be open for extension but closed for
            modification. Add new functionality without changing existing
            code.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">L - Liskov Substitution Principle</h3>
          <p class="principle-description">
            Objects of a superclass should be replaceable with objects of a
            subclass without breaking the application.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">I - Interface Segregation Principle</h3>
          <p class="principle-description">
            Clients should not be forced to depend on interfaces they don't
            use. Create specific, focused interfaces.
          </p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">D - Dependency Inversion Principle</h3>
          <p class="principle-description">
            Classes should depend upon interfaces or abstract classes instead
            of concrete classes.
          </p>
        </div>
      </div>
    </div>

    <!-- Slide 11: When to Choose Which Approach -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Decision Matrix: When to Choose Which</h1>
        <p class="slide-subtitle">Technical factors for approach selection</p>
      </div>
      <div style="margin-bottom: 18px; text-align: center; color: #667eea; font-size: 1.05rem;">
        <strong>Reflection:</strong> Think about your current project‚Äîwhere does it fit in this matrix? What trade-offs
        are you currently making between readability and maintainability? (Share with your neighbor)
      </div>
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Factor</th>
            <th>Choose Clean Code When...</th>
            <th>Choose Clear Code When...</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Project Lifespan</strong></td>
            <td>Long-term (2+ years), multiple iterations</td>
            <td>Short-term scripts, prototypes, one-offs</td>
          </tr>
          <tr>
            <td><strong>Team Size</strong></td>
            <td>Large teams (5+ developers)</td>
            <td>Small teams (1-3 developers)</td>
          </tr>
          <tr>
            <td><strong>Code Complexity</strong></td>
            <td>Complex business logic, multiple domains</td>
            <td>Straightforward CRUD, minimal domain logic or business rules</td>
          </tr>
          <tr>
            <td><strong>Performance Requirements</strong></td>
            <td>Can afford abstraction overhead</td>
            <td>Need maximum performance, minimal abstraction layers and runtime overhead</td>
          </tr>
          <tr>
            <td><strong>Readability vs. Maintainability</strong></td>
            <td>Maintainability is critical</td>
            <td>Immediate understanding for current reader is paramount, even at cost of future flexibility</td>
          </tr>
          <tr>
            <td><strong>Codebase Age</strong></td>
            <td>Legacy code that needs refactoring</td>
            <td>New code that needs to be immediately understandable</td>
          </tr>
          <tr>
            <td><strong>Future Extension</strong></td>
            <td>Expect frequent feature additions or evolving requirements</td>
            <td>No significant future changes expected</td>
          </tr>
          <tr>
            <td><strong>Onboarding New Devs</strong></td>
            <td>Important to make architecture easy for new team members to understand over time</td>
            <td>Code will be used by known, small set of people who can quickly understand simpler approaches</td>
          </tr>
          <tr>
            <td><strong>Testing & Coverage</strong></td>
            <td>High automated test coverage required, needs solid structure to support testing</td>
            <td>Manual testing or throwaway code with minimal test requirements</td>
          </tr>
          <tr>
            <td><strong>Documentation Need</strong></td>
            <td>Expect thorough documentation to support longevity and handoff</td>
            <td>Documentation can be light because code is self-explanatory and short-lived</td>
          </tr>
          <tr>
            <td><strong>Regulatory/Compliance</strong></td>
            <td>Must meet compliance standards (e.g., medical, finance)</td>
            <td>No compliance or audit constraints</td>
          </tr>
        </tbody>
      </table>
    </div>
    <!-- Slide 12: Advanced Naming Techniques -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Advanced Naming Techniques</h1>
        <p class="slide-subtitle">Naming strategies from Clean Code and Clear Code</p>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code Approach</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Domain-driven names:</strong> Use business terms consistently across
                the whole system (e.g., `Invoice`, `calculateTaxAmount`).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Avoid abbreviations:</strong> Use full words (`customerAddress`)
                instead of shortcuts (`custAddr`).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Positive boolean names:</strong> Prefer affirmations like
                `isEligibleForDiscount()` over confusing negations.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Action verbs for functions:</strong> Start names with verbs (`get`,
                `set`, `find`, `validate`, `update`, `send`).</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code Approach</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Human-first names:</strong> Prioritize immediate comprehension over
                strict domain correctness (e.g., `getCustomerBalance()` vs. `calcCustBal()`).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Contextual clarity:</strong> Names should make sense in isolation,
                without needing to cross-reference other code.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Function length vs. name detail:</strong> Longer functions require more
                descriptive names; very short functions can be simpler.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Avoid redundant context:</strong> Don't repeat unnecessary parts (e.g.,
                `user.getUser()` ‚Üí `user.get()`).</span>
            </li>
          </ul>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">‚ùå Poor Naming</div>
          <pre>function calc(u, t) {
  return u * t * 0.1; // What is calc? What are u and t?
}
let d = new Date();    // What does d represent?
let flag = false;      // Flag for what?</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Good Naming</div>
          <pre>function calculateTaxAmount(orderAmount, taxRate) {
  return orderAmount * taxRate;
}
const currentDate = DateTimeProvider.now();

// Clear, specific, self-explanatory</pre>
        </div>
      </div>
    </div>
    <!-- Slide 13: Functions with Fewer Side Effects -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Functions with Fewer Side Effects</h1>
        <p class="slide-subtitle">How Clean Code and Clear Code reduce unintended behavior</p>
      </div>
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code Perspective</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Pure functions:</strong> Always produce the same output for the same
                input and do not modify external state or rely on hidden inputs.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Command-Query Separation:</strong> A function should either return data
                OR change state‚Äînever both.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Avoid global variables:</strong> Prevent unpredictable dependencies and
                bugs by avoiding global or static state.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Testable design:</strong> Pure, side-effect-free functions are easier
                to test and reason about.</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code Perspective</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Explicit behavior:</strong> Use clear names to signal side effects
                (e.g., `saveUser()` clearly implies a write action).</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Minimize mutation:</strong> Return new objects instead of changing
                arguments directly whenever possible.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Read-only functions:</strong> Prefer functions that only read and
                return data; they are safer and easier to understand.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Single action per function:</strong> Split functions with multiple side
                effects into smaller, more focused ones.</span>
            </li>
          </ul>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">‚ùå Bad Example</div>
          <pre>function updateCart(cart, item) {
  cart.items.push(item);
  cart.total += item.price;
}

// ‚ö†Ô∏è Directly mutates cart, making state management 
// and debugging harder.</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Good Example</div>
          <pre>function addItemToCart(cart, item) {
  const newItems = [...cart.items, item];
  const newTotal = cart.total + item.price;
  return { ...cart, items: newItems, total: newTotal };
}

// ‚úÖ Creates and returns a new cart object without 
// mutating the original; easier to test and predict.</pre>
        </div>
      </div>
    </div>
    <!-- Slide: Hybrid Approach -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Hybrid Approach: Best of Both Worlds</h1>
        <p class="slide-subtitle">When to combine Clean Code and Clear Code</p>
      </div>

      <!-- Why Use Hybrid Section -->
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">‚úÖ Why use a hybrid?</h3>
          <ul style="list-style-type: disc; padding-left: 20px; color: #555; margin-top: 10px;">
            <li><strong>Real-world constraints:</strong> You often need maintainability (Clean Code) and immediate
              readability (Clear Code), especially on fast-moving projects.</li>
            <li><strong>Team diversity:</strong> Some teammates prefer structured abstractions, while others need quick,
              direct understanding.</li>
            <li><strong>Balanced performance and design:</strong> You can keep critical paths direct and clear while
              maintaining an overall clean, testable architecture.</li>
          </ul>
        </div>
      </div>

      <!-- Practical Example Section -->
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">üí° Practical Example</h3>
          <pre
            style="background:#2d3748;color:#e2e8f0;padding:15px;border-radius:8px;font-size:0.95rem;overflow-x:auto;"><code>class UserService {
  // Clean Code: Strong typing and single responsibility
  async createUserAccount(userData: CreateUserRequest): Promise&lt;{ success: boolean; user?: User; errors?: string[] }&gt; {
    // Clear Code: Explicit step-by-step logic

    // Step 1: Validate
    const validationErrors = this.validateUserData(userData);
    if (validationErrors.length > 0) {
      return { success: false, errors: validationErrors };
    }

    // Step 2: Save to database
    const newUser = await this.saveUserToDatabase(userData);

    // Step 3: Send welcome email
    await this.sendWelcomeEmail(newUser);

    // Step 4: Return success
    return { success: true, user: newUser };
  }

  private validateUserData(userData: CreateUserRequest): string[] {
    const errors: string[] = [];
    if (!userData.email.includes('@')) {
      errors.push('Invalid email format.');
    }
    if (userData.password.length < 8) {
      errors.push('Password must be at least 8 characters.');
    }
    return errors;
  }

  private async saveUserToDatabase(userData: CreateUserRequest): Promise&lt;User&gt; {
    // Imagine ORM or repository logic here
    return db.user.create(userData);
  }

  private async sendWelcomeEmail(user: User): Promise&lt;void&gt; {
    // Email service logic here
    await emailService.send({
      to: user.email,
      subject: 'Welcome!',
      body: 'Thank you for joining us.',
    });
  }
}</code></pre>
        </div>
      </div>

      <!-- Why This is Hybrid Section -->
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Clean Code Elements</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Strong typing:</strong> `CreateUserRequest`, `User` types</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Small, single-purpose methods:</strong> `validateUserData`,
                `saveUserToDatabase`, `sendWelcomeEmail`</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Separation of concerns:</strong> Each method has one clear
                responsibility</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Testable design:</strong> Private methods can be easily unit
                tested</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Clear Code Elements</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Straightforward, linear flow:</strong> Easy to read without jumping
                around</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Explicit, descriptive names:</strong> Clearly show each step</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Immediate error handling:</strong> Validation logic up front</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Step-by-step comments:</strong> Guide the reader through the
                process</span>
            </li>
          </ul>
        </div>
      </div>

      <!-- Practical Takeaway Section -->
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">üí¨ Practical Takeaway</h3>
          <div
            style="background: #f7fafc; border-left: 4px solid #667eea; padding: 15px; margin-top: 10px; border-radius: 0 8px 8px 0;">
            <p style="margin: 0; font-style: italic; color: #4a5568;">
              Combine <strong>clean architectural structure</strong> (abstractions, testability) with <strong>clear,
                easy-to-follow local logic</strong> (linear steps, explicit conditions) to make your code robust
              <em>and</em> approachable.
            </p>
          </div>
        </div>
      </div>
    </div>
    <!-- Slide: Writing Readable Tests -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Writing Readable Tests</h1>
        <p class="slide-subtitle">Best practices from TDD, Clean Code, and Clear Code</p>
      </div>
      <div class="single-column">
        <div class="principle-card">
          <h3 class="principle-title">1. One Assert Per Test</h3>
          <p class="principle-description">Each test should verify one behavior only. Multiple asserts can obscure
            what's being tested.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">2. Meaningful Test Names</h3>
          <p class="principle-description">Use descriptive names like `should_throw_error_when_user_not_found()` rather
            than vague ones like `testLogin()`.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">3. Arrange-Act-Assert Pattern</h3>
          <p class="principle-description">Structure each test clearly: setup (arrange), execute (act), verify (assert).
            Improves readability and debugging.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">4. Avoid Magic Numbers</h3>
          <p class="principle-description">Replace arbitrary numbers like `42` with named constants or comments
            explaining their significance.</p>
        </div>
        <div class="principle-card">
          <h3 class="principle-title">5. Don't Skip Edge Cases</h3>
          <p class="principle-description">Tests should cover edge cases like empty strings, nulls, and invalid
            inputs‚Äîthese are often where bugs hide.</p>
        </div>
      </div>
      <div class="code-container">
        <div class="code-example code-bad">
          <div class="code-title">‚ùå Poorly Written Test</div>
          <pre>test('login', () => {
  let u = new User('bob', 'pass123');
  assert(login(u));
});</pre>
        </div>
        <div class="code-example code-good">
          <div class="code-title">‚úÖ Well-Written Test</div>
          <pre>test('login_should_return_true_for_valid_credentials', () => {
  // Arrange
  const validUser = new User('alice', 'securePass!');

  // Act
  const result = login(validUser);

  // Assert
  expect(result).toBe(true);
});</pre>
        </div>
      </div>
    </div>
    <!-- Slide 14: Conclusion -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">Conclusion</h1>
        <p class="slide-subtitle">Clean Code and Clear Code: Two Sides of the Same Coin</p>
      </div>

      <!-- Summary Section -->
      <div class="content-grid">
        <div class="content-column">
          <h2 class="column-title">üßº Key Takeaways - Clean Code</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Write code for humans first:</strong> Computers will run anything, but
                humans need clarity.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Small, focused functions:</strong> Each function should do one thing
                and do it well.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Meaningful names:</strong> Names should reveal intent and avoid
                ambiguity.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Abstraction matters:</strong> Use SOLID principles to build scalable,
                maintainable systems.</span>
            </li>
          </ul>
        </div>
        <div class="content-column">
          <h2 class="column-title">üëÅÔ∏è Key Takeaways - Clear Code</h2>
          <ul class="feature-list">
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Readability over cleverness:</strong> Simple, explicit code beats smart
                tricks.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Linear flow is king:</strong> Avoid deeply nested logic; keep code
                top-to-bottom.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Minimize cognitive load:</strong> Reduce mental effort required to
                understand code.</span>
            </li>
            <li class="feature-item">
              <span class="feature-icon"></span>
              <span class="feature-text"><strong>Practical naming:</strong> Prioritize immediate comprehension over
                strict domain accuracy.</span>
            </li>
          </ul>
        </div>
      </div>

      <!-- Final Thoughts -->
      <div class="quote" style="margin-top: 40px;">
        "Clean Code emphasizes design and architecture. Clear Code focuses on readability and simplicity. The best
        developers use both."
        <div class="quote-author">‚Äî Modern Software Development Philosophy</div>
      </div>

      <!-- Closing Message -->
      <div class="single-column" style="text-align: center; margin-top: 50px;">
        <h2 style="font-size: 1.6rem; color: #333;">Final Thoughts</h2>
        <p style="font-size: 1.1rem; color: #666; max-width: 800px; margin: 0 auto; line-height: 1.6;">
          While Robert C. Martin's *Clean Code* provides a strong foundation for building robust, scalable systems,
          *Clear Code* reminds us that every line of code must be understood by humans first.
          By combining these philosophies, you can write code that is not only maintainable and extensible,
          but also easy to read, test, and modify‚Äîeven years later or by new team members.
        </p>
        <p style="font-size: 1.1rem; color: #666; margin-top: 20px;">
          Strive to write code that is clean <em>and</em> clear ‚Äî because great code serves both machines and people.
        </p>
        <div style="margin-top: 35px; color: #764ba2; font-size: 1.15rem; font-weight: 500;">
          <strong>Call to Action:</strong> I challenge everyone here: pick one principle from today‚Äîeither Clean or
          Clear‚Äîand apply it to your next code review. Then share your experience with the team!
        </div>
      </div>
    </div>
    <!-- Slide 15: References -->
    <div class="slide">
      <div class="slide-header">
        <h1 class="slide-title">References & Further Reading</h1>
        <p class="slide-subtitle">Sources that shaped our understanding of clean and clear code</p>
      </div>

      <!-- Reference Cards -->
      <div class="single-column" style="max-width: 900px; margin: 0 auto;">

        <!-- Clean Code Book -->
        <div class="principle-card" style="margin-bottom: 30px;">
          <h3 class="principle-title">üìò Clean Code: A Handbook of Agile Software Craftsmanship</h3>
          <p class="principle-description">
            By Robert C. Martin (Uncle Bob)<br>
            ISBN: 978-0132350884<br>
            This foundational book defines what clean code looks like and provides practical advice for writing
            maintainable software.
          </p>
          <a href="https://github.com/Gatjuat-Wicteat-Riek/clean-code-book/blob/master/Clean%20Code%20(%20PDFDrive.com%20).pdf"
            target="_blank" style="color: #667eea; text-decoration: none;">Github Link</a>
        </div>

        <!-- FreeCodeCamp Article -->
        <div class="principle-card" style="margin-bottom: 30px;">
          <h3 class="principle-title">üëÅÔ∏è Clear Code ‚Äì How to Write Code That Is Easy to Read</h3>
          <p class="principle-description">
            By freeCodeCamp<br>
            Published on: https://www.freecodecamp.org/news/clear-code-how-to-write-code-that-is-easy-to-read/ <br>
            Focuses on readability-first principles and practical naming, structure, and formatting techniques.
          </p>
          <a href="https://www.freecodecamp.org/news/clear-code-how-to-write-code-that-is-easy-to-read/ "
            target="_blank" style="color: #667eea; text-decoration: none;">Read Online</a>
        </div>

        <!-- Additional Resources -->
        <div class="principle-card">
          <h3 class="principle-title">üìö Additional Recommended Reading</h3>
          <ul style="list-style-type: disc; padding-left: 20px; color: #555;">
            <li><strong>Refactoring: Improving the Design of Existing Code</strong> by Martin Fowler</li>
            <li><strong>The Pragmatic Programmer</strong> by Andrew Hunt and David Thomas</li>
            <li><strong>Code Complete</strong> by Steve McConnell</li>
            <li><strong>You Don't Know JS</strong> series by Kyle Simpson (for JavaScript developers)</li>
          </ul>
        </div>

      </div>
    </div>
    <!-- Slides END -->

    <!-- Navigation Controls (Projector Style) -->
    <div class="nav-controls">
      <button class="nav-btn" id="prevBtn" onclick="navigate(-1)">Previous</button>
      <div class="slide-counter" id="slideCounter"></div>
      <button class="nav-btn" id="nextBtn" onclick="navigate(1)">Next</button>
    </div>
    <script>
      let currentSlide = 0;
      const slides = document.querySelectorAll('.slide');
      const slideCounter = document.getElementById('slideCounter');
      const navControls = document.querySelector('.nav-controls');

      // Initialize slide counter on page load
      slideCounter.textContent = `1 / ${slides.length}`;

      function navigate(direction) {
        slides[currentSlide].classList.remove('active');
        currentSlide += direction;
        if (currentSlide < 0) {
          currentSlide = slides.length - 1;
        } else if (currentSlide >= slides.length) {
          currentSlide = 0;
        }
        slides[currentSlide].classList.add('active');
        slideCounter.textContent = `${currentSlide + 1} / ${slides.length}`;
      }

      // Show/hide navigation controls based on cursor position
      function handleMouseMove(event) {
        const windowHeight = window.innerHeight;
        const mouseY = event.clientY;
        const bottomThreshold = windowHeight * 0.2; // Bottom 20% of screen

        if (mouseY > windowHeight - bottomThreshold) {
          navControls.style.opacity = '1';
        } else {
          navControls.style.opacity = '0';
        }
      }

      // Add mouse move listener
      document.addEventListener('mousemove', handleMouseMove);

      // Also show controls when hovering directly over them
      navControls.addEventListener('mouseenter', () => {
        navControls.style.opacity = '1';
      });

      navControls.addEventListener('mouseleave', (event) => {
        // Only hide if mouse is not in the bottom area
        const windowHeight = window.innerHeight;
        const mouseY = event.clientY;
        const bottomThreshold = windowHeight * 0.2;

        if (mouseY <= windowHeight - bottomThreshold) {
          navControls.style.opacity = '0';
        }
      });
    </script>
  </div>
  <!-- End Projector Presentation Wrapper -->
</body>

</html>